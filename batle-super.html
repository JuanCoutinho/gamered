<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Royale .io - Professional Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Arial, sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI LAYOUT ORIGINAL RESTAURADO */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Top Info */
        #top-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #zone-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
        }

        #zone-timer .label {
            background: rgba(230, 126, 34, 0.9);
            padding: 5px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 800;
            text-transform: uppercase;
        }

        #zone-timer .time {
            font-size: 40px;
            font-weight: 900;
            margin-top: 5px;
            text-shadow: 3px 3px 0 #000;
        }

        /* Skill Bar */
        #skill-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .skill-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #555;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            transition: border-color 0.2s;
        }

        .skill-slot.active {
            border-color: #f1c40f;
            box-shadow: 0 0 15px #f1c40f;
        }

        .skill-slot .icon {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }

        .skill-slot .cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.8);
            transition: height 0.1s linear;
        }

        .skill-slot .key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }

        /* Screens */
        #class-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }

        .cards-container {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }

        .hero-card {
            width: 220px;
            background: #222;
            border: 4px solid #444;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            color: white;
        }

        .hero-card:hover {
            transform: translateY(-10px);
            border-color: #fff;
        }

        .hero-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 15px auto;
            border: 4px solid #000;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            display: none;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.9);
            padding: 50px;
            border-radius: 20px;
            border: 4px solid #fff;
        }

        button.btn-restart {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 20px;
        }

        button.btn-restart:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        /* Damage Flash */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>
    <div id="flash-overlay"></div>

    <div id="ui-layer">
        <div id="top-stats">
            Alive: <span id="alive-count" style="color:#e74c3c">15</span>
            <br>
            <div style="margin-top: 10px; font-size: 14px;">
                HP: <span id="hp-text">100</span> / <span id="hp-max">100</span>
                <br>
                Energy: <span id="energy-text">100</span> / 100
            </div>
        </div>

        <div id="zone-timer">
            <div class="label">ZONE CLOSING</div>
            <div class="time" id="zone-display">00:00</div>
        </div>

        <div id="skill-bar">
            <!-- Gerado via JS -->
        </div>

        <div id="game-over">
            <h1 style="font-size: 64px; margin-bottom: 20px;">GAME OVER</h1>
            <h2 id="go-rank" style="color: #f1c40f;">Rank #1</h2>
            <h3 id="go-kills" style="color: #aaa; margin-bottom: 30px;">Kills: 0</h3>
            <button class="btn-restart" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <div id="class-select">
        <h1 style="color:white; text-transform: uppercase; letter-spacing: 5px;">Select Your Hero</h1>
        <div class="cards-container" id="hero-list"></div>
    </div>

    <script>
        /**
         * ==========================================
         * 1. CONFIGURATION & DATA
         * ==========================================
         */
        const CONFIG = {
            worldSize: 2500,
            heroes: {
                batman: {
                    name: "Batman", color: "#2c3e50", hp: 140, speed: 280,
                    desc: "Stealthy tank. Skill: Smoke Bomb.",
                    icon: "ü¶á", skillCd: 5, radius: 24, energyCost: 20
                },
                goku: {
                    name: "Goku", color: "#e67e22", hp: 110, speed: 300,
                    desc: "High DPS. Skill: Kamehameha.",
                    icon: "üî•", skillCd: 7, radius: 20, energyCost: 25
                },
                flash: {
                    name: "Flash", color: "#c0392b", hp: 90, speed: 400,
                    desc: "Speedster. Skill: Time Dilation.",
                    icon: "‚ö°", skillCd: 10, radius: 18, energyCost: 30
                },
                saitama: {
                    name: "Saitama", color: "#f1c40f", hp: 300, speed: 220,
                    desc: "One Punch Man. Skill: Serious Punch.",
                    icon: "üëä", skillCd: 12, radius: 22, energyCost: 20
                },
                superman: {
                    name: "Superman", color: "#2980b9", hp: 200, speed: 340,
                    desc: "Man of Steel. Skill: Heat Vision.",
                    icon: "ü¶∏", skillCd: 6, radius: 24, energyCost: 25
                },
                kratos: {
                    name: "Kratos", color: "#922b21", hp: 160, speed: 260,
                    desc: "God of War. Skill: Spartan Rage.",
                    icon: "‚öîÔ∏è", skillCd: 5, radius: 26, energyCost: 20
                },
                wolverine: {
                    name: "Wolverine", color: "#f39c12", hp: 140, speed: 300,
                    desc: "Mutant brawler. Skill: Berserker Rage.",
                    icon: "üê∫", skillCd: 4, radius: 22, energyCost: 15, meleeOnly: true
                },
                hulk: {
                    name: "Hulk", color: "#27ae60", hp: 350, speed: 200,
                    desc: "Strongest there is. Skill: Thunderclap.",
                    icon: "üí™", skillCd: 6, radius: 32, energyCost: 30, meleeOnly: true
                }
            }
        };

        /**
         * ==========================================
         * 2. CORE ENGINE (MATH & AUDIO)
         * ==========================================
         */
        class Vector2 {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector2(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x ** 2 + this.y ** 2); }
            normalize() { const m = this.mag(); return m === 0 ? new Vector2(0, 0) : new Vector2(this.x / m, this.y / m); }
            dist(v) { return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2); }
            copy() { return new Vector2(this.x, this.y); }
        }

        const Utils = {
            rand: (min, max) => Math.random() * (max - min) + min,
            clamp: (v, min, max) => Math.min(Math.max(v, min), max),
            // Fun√ß√£o para escurecer/clarear hex colors
            shadeColor: (color, percent) => {
                let f = parseInt(color.slice(1), 16), t = percent < 0 ? 0 : 255, p = percent < 0 ? percent * -1 : percent, R = f >> 16, G = f >> 8 & 0x00FF, B = f & 0x0000FF;
                return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
            }
        };

        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.15; // Quieter for atmosphere
                this.master.connect(this.ctx.destination);
                this.startAmbience();
            }

            // Serious, weighted sound effects
            playTone(type, freqStart, freqEnd, duration, vol = 1.0) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freqStart, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(freqEnd, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.master);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration, vol = 0.5) {
                // White noise burst for impact
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(gain);
                gain.connect(this.master);
                noise.start();
            }

            startAmbience() {
                // Low frequency rumble for tension
                if (this.ctx.state === 'suspended') return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = 40; // Very low rumble
                gain.gain.value = 0.02; // Very quiet atmospheric layer
                osc.connect(gain);
                gain.connect(this.master);
                osc.start();
            }

            // Redesigned SFX - serious and weighty
            sfxShoot() {
                this.playTone('sawtooth', 100, 50, 0.15, 0.8); // Deep bass punch
            }
            sfxHit() {
                this.playNoise(0.1, 0.4); // Metallic impact
                this.playTone('sawtooth', 80, 40, 0.25, 0.6); // Heavy thud
            }
            sfxDash() {
                this.playTone('sine', 400, 100, 0.4, 0.5); // Swoosh descent
            }
            sfxSkill() {
                this.playTone('triangle', 150, 600, 0.8, 0.7); // Power charge
                setTimeout(() => this.playTone('sine', 600, 400, 0.3, 0.5), 200);
            }
            sfxDie() {
                this.playTone('sawtooth', 80, 20, 0.6, 1.0); // Death groan
                this.playNoise(0.3, 0.3); // Body impact
            }
            sfxCollect() {
                this.playTone('sine', 500, 700, 0.2, 0.4); // Quick pickup chime
            }
            sfxVictory() {
                // Triumphant chord progression
                this.playTone('sine', 440, 550, 1.5, 0.6);
                setTimeout(() => this.playTone('sine', 550, 660, 1.5, 0.6), 300);
                setTimeout(() => this.playTone('triangle', 330, 440, 2.0, 0.5), 600);
            }
        }
        const Audio = new SoundManager();

        /**
         * ==========================================
         * 3. GAME OBJECTS (ENTITIES)
         * ==========================================
         */
        class GameObject {
            constructor(x, y) {
                this.pos = new Vector2(x, y);
                this.z = 0; // Altura do ch√£o (pulo/voo)
                this.height3D = 0; // Altura f√≠sica do objeto (para desenhar paredes)
                this.dead = false;
            }
            update(dt) { }
            draw(ctx) { }
        }

        class Wall extends GameObject {
            constructor(x, y, w, h) {
                super(x, y);
                this.w = w;
                this.h = h;
                this.height3D = 60; // Paredes altas
            }
            draw(ctx) {
                // Renderiza√ß√£o 2.5D: Desenha a face frontal e depois o topo
                const topY = this.pos.y - this.height3D;

                // Sombra da parede
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(this.pos.x + 10, this.pos.y + 10, this.w, this.h);

                // Face Frontal (mais escura)
                ctx.fillStyle = '#444';
                ctx.fillRect(this.pos.x, topY + this.h, this.w, this.height3D);
                ctx.strokeStyle = '#222';
                ctx.strokeRect(this.pos.x, topY + this.h, this.w, this.height3D);

                // Topo (mais claro)
                ctx.fillStyle = '#666';
                ctx.fillRect(this.pos.x, topY, this.w, this.h);
                ctx.strokeRect(this.pos.x, topY, this.w, this.h);
            }
        }

        class Particle extends GameObject {
            constructor(x, y, color, type = 'default') {
                super(x, y);
                this.vel = new Vector2(Utils.rand(-100, 100), Utils.rand(-100, 100));
                this.life = 1.0;
                this.maxLife = 1.0;
                this.z = Utils.rand(5, 30);
                this.color = color;
                this.type = type; // 'blood', 'spark', 'dust', 'default'
                this.size = type === 'spark' ? 3 : (type === 'dust' ? 6 : 5);
                this.gravity = type === 'spark' ? 0 : (type === 'dust' ? 20 : 60);

                // Type-specific adjustments
                if (type === 'blood') {
                    this.vel.y = Utils.rand(-150, -50); // Upward spray
                    this.life = Utils.rand(0.5, 0.8);
                    this.maxLife = this.life;
                } else if (type === 'spark') {
                    this.vel = new Vector2(Utils.rand(-200, 200), Utils.rand(-200, 200));
                    this.life = Utils.rand(0.2, 0.4);
                    this.maxLife = this.life;
                } else if (type === 'dust') {
                    this.vel.x = Utils.rand(-30, 30);
                    this.vel.y = Utils.rand(-40, -20);
                    this.life = Utils.rand(0.6, 1.2);
                    this.maxLife = this.life;
                    this.opacity = 0.4;
                }
            }

            update(dt) {
                this.pos = this.pos.add(this.vel.mult(dt));
                this.z -= this.gravity * dt; // Gravity
                if (this.z < 0) {
                    this.z = 0;
                    this.vel = this.vel.mult(0.4); // Bounce damping
                    if (this.type === 'blood') this.dead = true; // Blood splatters and stays
                }
                this.life -= dt * (this.type === 'spark' ? 5 : 2);
                if (this.life <= 0) this.dead = true;
            }

            draw(ctx) {
                const alpha = (this.life / this.maxLife) * (this.opacity || 1.0);
                ctx.globalAlpha = alpha;

                if (this.type === 'spark') {
                    // Bright glowing spark
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = this.color;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y - this.z, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Regular particle (blood/dust)
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.pos.x - this.size / 2, this.pos.y - this.z - this.size / 2, this.size, this.size);
                }

                ctx.globalAlpha = 1;
            }
        }

        class Loot extends GameObject {
            constructor(x, y, type) {
                super(x, y);
                this.type = type; // 'HEALTH' or 'ENERGY'
                this.value = type === 'HEALTH' ? 40 : 30;
                this.radius = 12;
                this.floatTime = Math.random() * 100;
            }

            update(dt) {
                this.floatTime += dt * 4;
            }

            draw(ctx) {
                const yOff = Math.sin(this.floatTime) * 4;
                const color = this.type === 'HEALTH' ? '#e74c3c' : '#3498db';

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.pos.x, this.pos.y + 8, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.shadowBlur = 12;
                ctx.shadowColor = color;

                // Orb
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y + yOff, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.pos.x - 3, this.pos.y + yOff - 3, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        class Entity extends GameObject {
            constructor(x, y, type) {
                super(x, y);
                this.config = CONFIG.heroes[type] || CONFIG.heroes.batman; // Fallback
                this.radius = this.config.radius;
                this.color = this.config.color;
                this.maxHp = this.config.hp;
                this.hp = this.maxHp;
                this.speed = this.config.speed;
                this.maxEnergy = 100;
                this.energy = this.maxEnergy;

                this.vel = new Vector2(0, 0);
                this.acc = new Vector2(0, 0);
                this.friction = 0.92;
                this.aimAngle = 0;
                this.visualAngle = 0; // Smoothed rotation
                this.flashTime = 0;
                this.redTint = 0; // Red damage tint
                this.dustTimer = 0; // For dust trail

                // Cooldowns
                this.attackCd = 0;
                this.skillCd = 0;
                this.dashCd = 0;

                // Special states
                this.rageActive = false; // Kratos
                this.berserkerActive = false; // Wolverine
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.flashTime = 0.15; // Flash white
                this.redTint = 0.3; // Red overlay fade
                Audio.sfxHit();

                // Blood spray particles (5-8)
                const bloodCount = Utils.rand(5, 8);
                for (let i = 0; i < bloodCount; i++) {
                    Game.particles.push(new Particle(this.pos.x, this.pos.y, '#8b0000', 'blood'));
                }

                if (this.hp <= 0) {
                    this.dead = true;
                    Audio.sfxDie();
                    // Death explosion
                    for (let i = 0; i < 20; i++) {
                        Game.particles.push(new Particle(this.pos.x, this.pos.y, this.color, 'default'));
                    }
                }
            }

            updatePhysics(dt) {
                // Smooth rotation lerp
                let angleDiff = this.aimAngle - this.visualAngle;
                // Normalize angle difference to [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                this.visualAngle += angleDiff * 0.25; // Smooth follow

                // Aplica velocidade e acelera√ß√£o
                this.vel = this.vel.add(this.acc.mult(dt));
                let nextPos = this.pos.add(this.vel.mult(dt));

                // Dust trail when moving fast
                if (this.vel.mag() > 100 && this === Game.player) {
                    this.dustTimer += dt;
                    if (this.dustTimer > 0.08) {
                        this.dustTimer = 0;
                        Game.particles.push(new Particle(this.pos.x, this.pos.y, '#8b7355', 'dust'));
                    }
                }

                // Colis√£o com Paredes (Sliding)
                if (!Game.checkWall(nextPos.x, this.pos.y, this.radius)) this.pos.x = nextPos.x;
                else this.vel.x = 0;

                if (!Game.checkWall(this.pos.x, nextPos.y, this.radius)) this.pos.y = nextPos.y;
                else this.vel.y = 0;

                // Atrito e Limites do Mundo
                this.vel = this.vel.mult(this.friction);
                this.acc = new Vector2(0, 0);
                this.pos.x = Utils.clamp(this.pos.x, 0, CONFIG.worldSize);
                this.pos.y = Utils.clamp(this.pos.y, 0, CONFIG.worldSize);

                // Decay visual effects
                if (this.flashTime > 0) this.flashTime -= dt;
                if (this.redTint > 0) this.redTint -= dt * 3;
            }

            draw(ctx) {
                // 1. Sombra no ch√£o (pos.y real)
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.pos.x, this.pos.y, this.radius, this.radius * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // 2. Corpo (Estilo Surviv.io + 2.5D Lift)
                const lift = 15 + this.z; // Levanta o corpo do ch√£o
                const bodyY = this.pos.y - lift;

                ctx.lineWidth = 3;
                ctx.strokeStyle = '#000';
                ctx.fillStyle = this.flashTime > 0 ? '#fff' : this.color;

                // "Parede" do corpo (ilus√£o de volume)
                ctx.beginPath();
                ctx.arc(this.pos.x, bodyY + 5, this.radius, 0, Math.PI * 2);
                const darker = Utils.shadeColor(this.color, -0.3);
                if (this.flashTime <= 0) {
                    ctx.fillStyle = darker;
                    ctx.fill();
                    ctx.stroke();
                }

                // Topo do corpo
                ctx.fillStyle = this.flashTime > 0 ? '#fff' : this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, bodyY, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // 3. M√£os (Surviv Style) - Use visualAngle for smooth rotation
                const handDist = this.radius + 8;
                const handSize = this.radius * 0.4;

                const rX = this.pos.x + Math.cos(this.visualAngle + 0.5) * handDist;
                const rY = bodyY + Math.sin(this.visualAngle + 0.5) * handDist;
                const lX = this.pos.x + Math.cos(this.visualAngle - 0.5) * handDist;
                const lY = bodyY + Math.sin(this.visualAngle - 0.5) * handDist;

                ctx.fillStyle = this.flashTime > 0 ? '#fff' : darker;
                [{ x: rX, y: rY }, { x: lX, y: lY }].forEach(h => {
                    ctx.beginPath(); ctx.arc(h.x, h.y, handSize, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                });

                // Red damage tint (fades after white flash)
                if (this.redTint > 0) {
                    ctx.globalAlpha = this.redTint;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, bodyY, this.radius + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Barra de Vida
                if (this !== Game.player || Game.player.dead) {
                    const pct = this.hp / this.maxHp;
                    ctx.fillStyle = 'red'; ctx.fillRect(this.pos.x - 20, bodyY - 40, 40, 5);
                    ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.pos.x - 20, bodyY - 40, 40 * pct, 5);
                }
            }
        }

        class Player extends Entity {
            constructor(type) {
                super(CONFIG.worldSize / 2, CONFIG.worldSize / 2, type);
                this.flashSpeedMultiplier = 1.0; // For Flash time compensation
            }
            update(dt) {
                // Wolverine passive regen
                if (this.config.name === "Wolverine" && this.hp < this.maxHp) {
                    this.hp = Math.min(this.maxHp, this.hp + 2 * dt);
                }

                // Special state timers
                if (this.rageActive && this.rageTimer) {
                    this.rageTimer -= dt;
                    if (this.rageTimer <= 0) this.rageActive = false;
                }
                if (this.berserkerActive && this.berserkerTimer) {
                    this.berserkerTimer -= dt;
                    if (this.berserkerTimer <= 0) this.berserkerActive = false;
                }

                // Input
                let dir = new Vector2(0, 0);
                if (Input.keys['w']) dir.y = -1;
                if (Input.keys['s']) dir.y = 1;
                if (Input.keys['a']) dir.x = -1;
                if (Input.keys['d']) dir.x = 1;

                if (dir.mag() > 0) {
                    dir = dir.normalize();
                    let moveSpeed = this.speed * this.flashSpeedMultiplier;
                    if (this.rageActive) moveSpeed *= 1.4; // Kratos rage boost
                    if (this.berserkerActive && this.config.name === "Wolverine") moveSpeed *= 1.6; // Wolverine berserker speed
                    this.acc = dir.mult(moveSpeed * 8);
                }

                // Aim
                const mouseWorld = Game.camera.screenToWorld(Input.mouse);
                this.aimAngle = Math.atan2(mouseWorld.y - this.pos.y, mouseWorld.x - this.pos.x);

                // Actions
                this.handleCombat(dt, mouseWorld);
                this.handleZoneDamage(dt);
                this.collectLoot(dt);
                this.updatePhysics(dt);
            }

            collectLoot(dt) {
                for (let i = Game.loots.length - 1; i >= 0; i--) {
                    const loot = Game.loots[i];
                    if (this.pos.dist(loot.pos) < this.radius + loot.radius) {
                        if (loot.type === 'HEALTH') {
                            this.hp = Math.min(this.maxHp, this.hp + loot.value);
                        } else if (loot.type === 'ENERGY') {
                            this.energy = Math.min(this.maxEnergy, this.energy + loot.value);
                        }
                        Game.loots.splice(i, 1);
                        Audio.sfxCollect();
                        for (let k = 0; k < 8; k++) Game.addParticle(loot.pos.x, loot.pos.y, loot.type === 'HEALTH' ? '#e74c3c' : '#3498db');
                    }
                }
            }

            handleCombat(dt, mousePos) {
                // Cooldowns tick
                if (this.attackCd > 0) this.attackCd -= dt;
                if (this.skillCd > 0) this.skillCd -= dt;
                if (this.dashCd > 0) this.dashCd -= dt;

                // Basic Attack (Click)
                if (Input.mouseLeft && this.attackCd <= 0) {
                    const aimDir = mousePos.sub(this.pos).normalize();

                    // Determine if melee-only hero
                    const isMelee = this.config.meleeOnly || this.config.name === "Saitama" || this.config.name === "Kratos";

                    if (isMelee) {
                        // MELEE ATTACK
                        let attackSpeed = 0.4;
                        let meleeRange = 40;
                        let damage = 35;

                        // Hero-specific melee tuning
                        if (this.config.name === "Wolverine") {
                            attackSpeed = 0.25; // Fast slashes
                            meleeRange = 45;
                            damage = 22;
                            if (this.berserkerActive) {
                                attackSpeed = 0.08; // Ultra fast (12/sec)
                                damage = 30;
                            }
                        } else if (this.config.name === "Hulk") {
                            attackSpeed = 0.6; // Slower heavy punches
                            meleeRange = 50; // Long reach
                            damage = 45; // High damage
                        } else if (this.config.name === "Saitama") {
                            damage = 60;
                        } else if (this.config.name === "Kratos") {
                            damage = 35;
                            if (this.rageActive) damage *= 1.8;
                        }

                        this.attackCd = attackSpeed;
                        const punchPos = this.pos.add(aimDir.mult(meleeRange));

                        // Visual effects
                        for (let i = 0; i < 3; i++) {
                            Game.particles.push(new Particle(punchPos.x, punchPos.y, '#fff', 'spark'));
                        }

                        // Damage check
                        Game.checkAreaDamage(this, punchPos, 50, damage);

                        // Lifesteal for berserker Wolverine
                        if (this.config.name === "Wolverine" && this.berserkerActive) {
                            this.hp = Math.min(this.maxHp, this.hp + damage * 0.3);
                        }

                        Audio.sfxShoot();
                    } else {
                        // RANGED PROJECTILE
                        this.attackCd = 0.4;
                        let damage = 18;
                        if (this.berserkerActive) damage *= 1.3;
                        Game.spawnProjectile(this, this.pos, aimDir, damage);
                        Audio.sfxShoot();
                    }
                }

                // Skill (Right Click) - Check Energy First
                if (Input.mouseRight && this.skillCd <= 0 && this.energy >= this.config.energyCost) {
                    this.useSkill(mousePos);
                }

                // Dash (Space)
                if (Input.keys[' '] && this.dashCd <= 0) {
                    const moveDir = this.vel.mag() > 0 ? this.vel.normalize() : new Vector2(1, 0);
                    this.vel = moveDir.mult(1000); // Burst
                    this.dashCd = 3;
                    Audio.sfxDash();
                }
            }

            useSkill(mousePos) {
                this.skillCd = this.config.skillCd;
                this.energy -= this.config.energyCost; // Consume energy
                Audio.sfxSkill();
                const aimDir = mousePos.sub(this.pos).normalize();

                switch (this.config.name) {
                    case "Goku": // Kamehameha
                        Game.beams.push({
                            owner: this, start: this.pos.copy(), dir: aimDir, life: 0.5, width: 40, color: '#3498db'
                        });
                        Game.shake = 15;
                        break;

                    case "Batman": // Smoke Bomb
                        for (let i = 0; i < 15; i++)
                            Game.smokes.push({ pos: this.pos.add(new Vector2(Utils.rand(-60, 60), Utils.rand(-60, 60))), life: 4, r: Utils.rand(40, 70) });
                        break;

                    case "Flash": // Time Dilation (FIXED)
                        Game.timeScale = 0.2;
                        this.flashSpeedMultiplier = 1 / 0.2; // Compensate = 5x speed for Flash
                        setTimeout(() => {
                            Game.timeScale = 1.0;
                            this.flashSpeedMultiplier = 1.0;
                        }, 3000); // 3s real time
                        break;

                    case "Saitama": // Serious Punch
                        const punchPos = this.pos.add(aimDir.mult(60));
                        Game.createExplosion(punchPos.x, punchPos.y, 100, 'red');
                        Game.checkAreaDamage(this, punchPos, 100, 999); // Instant Kill
                        Game.shake = 30;
                        break;

                    case "Superman": // Heat Vision
                        Game.beams.push({
                            owner: this, start: this.pos.copy(), dir: aimDir, life: 0.8, width: 25, color: '#e74c3c'
                        });
                        Game.shake = 12;
                        break;

                    case "Kratos": // Spartan Rage
                        this.rageActive = true;
                        this.rageTimer = 6; // 6 seconds of rage
                        Game.createExplosion(this.pos.x, this.pos.y, 40, '#922b21');
                        Game.shake = 10;
                        break;

                    case "Wolverine": // Berserker Rage
                        this.berserkerActive = true;
                        this.berserkerTimer = 5; // 5 seconds of rage
                        // Visual: Red aura particles
                        for (let i = 0; i < 30; i++) {
                            Game.particles.push(new Particle(this.pos.x, this.pos.y, '#ff0000', 'default'));
                        }
                        Game.shake = 8;
                        break;

                    case "Hulk": // Thunderclap / Ground Pound
                        const smashRadius = 150;
                        const smashDamage = 80;

                        // Massive screen shake
                        Game.shake = 25;

                        // Shockwave visual - expanding ring
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                            const dist = Utils.rand(smashRadius * 0.8, smashRadius);
                            const px = this.pos.x + Math.cos(angle) * dist;
                            const py = this.pos.y + Math.sin(angle) * dist;
                            Game.particles.push(new Particle(px, py, '#8b7355', 'dust'));
                        }

                        // Central explosion
                        Game.createExplosion(this.pos.x, this.pos.y, 40, this.color);

                        // Damage + Knockback
                        Game.entities.forEach(e => {
                            if (e === this || e.dead) return;
                            const dist = this.pos.dist(e.pos);
                            if (dist < smashRadius) {
                                e.takeDamage(smashDamage);
                                // Knockback
                                const knockDir = e.pos.sub(this.pos).normalize();
                                e.vel = e.vel.add(knockDir.mult(800));
                                Game.kills++;
                            }
                        });
                        break;
                }
            }

            handleZoneDamage(dt) {
                const distCenter = this.pos.dist(new Vector2(CONFIG.worldSize / 2, CONFIG.worldSize / 2));
                if (distCenter > Game.zoneRadius) {
                    this.takeDamage(20 * dt);
                    document.getElementById('flash-overlay').style.opacity = 0.3;
                } else {
                    document.getElementById('flash-overlay').style.opacity = 0;
                }
            }
        }

        class Bot extends Entity {
            constructor() {
                const types = Object.keys(CONFIG.heroes);
                const type = types[Math.floor(Math.random() * types.length)];
                // Spawn longe do player e longe do centro (para correr pra zona)
                const x = Utils.rand(200, CONFIG.worldSize - 200);
                const y = Utils.rand(200, CONFIG.worldSize - 200);
                super(x, y, type);

                this.state = 'IDLE'; // FSM: IDLE, CHASE, ATTACK, FLEE_ZONE
                this.target = null;
                this.timer = 0;
            }

            update(dt) {
                // 1. Check Zone Safety (Alta prioridade)
                const center = new Vector2(CONFIG.worldSize / 2, CONFIG.worldSize / 2);
                const distToCenter = this.pos.dist(center);

                if (distToCenter > Game.zoneRadius * 0.9) {
                    this.state = 'FLEE_ZONE';
                } else if (this.state === 'FLEE_ZONE') {
                    this.state = 'IDLE'; // Seguro agora
                }

                // 2. FSM Logic
                switch (this.state) {
                    case 'FLEE_ZONE':
                        const dirZone = center.sub(this.pos).normalize();
                        this.acc = dirZone.mult(this.speed * 8);
                        this.aimAngle = Math.atan2(dirZone.y, dirZone.x);
                        break;

                    case 'IDLE':
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            // Tenta achar alvo
                            const enemy = Game.getNearestEnemy(this);
                            if (enemy && this.pos.dist(enemy.pos) < 600) {
                                this.target = enemy;
                                this.state = 'CHASE';
                            } else {
                                // Wander
                                const angle = Math.random() * Math.PI * 2;
                                this.acc = new Vector2(Math.cos(angle), Math.sin(angle)).mult(this.speed * 8);
                                this.timer = 1.0;
                            }
                        }
                        break;

                    case 'CHASE':
                        if (!this.target || this.target.dead || this.pos.dist(this.target.pos) > 700) {
                            this.state = 'IDLE';
                            break;
                        }
                        const dirToTarget = this.target.pos.sub(this.pos).normalize();
                        this.acc = dirToTarget.mult(this.speed * 8);
                        this.aimAngle = Math.atan2(dirToTarget.y, dirToTarget.x);

                        if (this.pos.dist(this.target.pos) < 300) {
                            this.state = 'ATTACK';
                        }
                        break;

                    case 'ATTACK':
                        if (!this.target || this.target.dead) { this.state = 'IDLE'; break; }
                        const aim = this.target.pos.sub(this.pos).normalize();
                        this.aimAngle = Math.atan2(aim.y, aim.x);
                        this.vel = this.vel.mult(0.9); // Para pra atirar

                        if (this.attackCd <= 0) {
                            Game.spawnProjectile(this, this.pos, aim, 10); // Menos dano que player
                            this.attackCd = 1.0; // Atira mais devagar
                        }
                        this.attackCd -= dt;

                        if (this.pos.dist(this.target.pos) > 350) this.state = 'CHASE';
                        break;
                }

                // 3. Flocking (Separation) - Evita que bots fiquem encavalados
                let separate = new Vector2(0, 0);
                Game.entities.forEach(e => {
                    if (e === this) return;
                    const d = this.pos.dist(e.pos);
                    if (d < 50 && d > 0) {
                        separate = separate.add(this.pos.sub(e.pos).normalize().mult(1 / d));
                    }
                });
                this.acc = this.acc.add(separate.mult(2000));

                // 4. Update Physics check zone damage
                this.updatePhysics(dt);
                if (distToCenter > Game.zoneRadius) this.takeDamage(10 * dt);
            }
        }

        class Projectile extends GameObject {
            constructor(owner, pos, dir, damage) {
                super(pos.x, pos.y);
                this.owner = owner;
                this.vel = dir.mult(800); // R√°pido
                this.damage = damage;
                this.life = 1.5;
                this.z = 15; // Altura do tiro
                this.radius = 6;
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mult(dt));
                this.life -= dt;
                if (this.life <= 0) this.dead = true;

                // Wall collision
                if (Game.checkWall(this.pos.x, this.pos.y, 2)) {
                    this.dead = true;
                    Game.createExplosion(this.pos.x, this.pos.y, 10, '#fff');
                }

                // Entity collision
                Game.entities.forEach(e => {
                    if (e === this.owner || e.dead) return;
                    // Verifica altura Z aproximada para n√£o acertar "ch√£o" se pular (futuro)
                    if (this.pos.dist(e.pos) < e.radius + this.radius) {
                        e.takeDamage(this.damage);
                        this.dead = true;
                        if (e.dead && this.owner === Game.player) Game.kills++;
                    }
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10; ctx.shadowColor = this.owner === Game.player ? '#3498db' : '#e74c3c';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y - this.z, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        /**
         * ==========================================
         * 4. GAME SYSTEM
         * ==========================================
         */
        const Input = { keys: {}, mouse: new Vector2(0, 0), mouseLeft: false, mouseRight: false };

        const Game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),

            player: null,
            entities: [],
            walls: [],
            projectiles: [],
            particles: [],
            beams: [], // Kamehamehas
            smokes: [], // Batman smokes
            loots: [], // Health & Energy orbs

            camera: {
                pos: new Vector2(0, 0),
                screenToWorld: (v) => v.add(Game.camera.pos)
            },

            zoneRadius: CONFIG.worldSize,
            timeScale: 1.0,
            kills: 0,
            shake: 0,
            won: false,

            init(heroKey) {
                this.resize();
                this.player = new Player(heroKey);
                this.entities = [this.player];

                // Populate World
                for (let i = 0; i < 30; i++) this.walls.push(new Wall(Utils.rand(0, CONFIG.worldSize), Utils.rand(0, CONFIG.worldSize), Utils.rand(50, 200), 40));
                for (let i = 0; i < 14; i++) this.entities.push(new Bot()); // 14 bots + 1 player = 15 alive

                // Spawn loot items
                for (let i = 0; i < 15; i++) {
                    const type = Math.random() < 0.5 ? 'HEALTH' : 'ENERGY';
                    this.loots.push(new Loot(Utils.rand(100, CONFIG.worldSize - 100), Utils.rand(100, CONFIG.worldSize - 100), type));
                }

                // UI Setup
                this.buildSkillBar();
                document.getElementById('class-select').style.display = 'none';

                this.lastTime = performance.now();
                requestAnimationFrame(t => this.loop(t));
            },

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            loop(now) {
                const dt = Math.min((now - this.lastTime) / 1000, 0.1) * this.timeScale;
                this.lastTime = now;

                this.update(dt);
                this.draw();

                if (!this.player.dead) requestAnimationFrame(t => this.loop(t));
                else this.showGameOver();
            },

            update(dt) {
                // Check win condition
                if (!this.won && this.entities.length === 1 && this.entities[0] === this.player) {
                    this.won = true;
                    this.showVictory();
                    return;
                }

                if (this.zoneRadius > 100) this.zoneRadius -= 15 * dt;
                if (this.shake > 0) this.shake -= dt * 20; if (this.shake < 0) this.shake = 0;

                // Update Arrays
                [...this.entities, ...this.projectiles, ...this.particles, ...this.loots].forEach(o => o.update(dt));
                this.entities = this.entities.filter(e => !e.dead);
                this.projectiles = this.projectiles.filter(p => !p.dead);
                this.particles = this.particles.filter(p => !p.dead);

                // Respawn loot if depleted
                if (this.loots.length < 5) {
                    const type = Math.random() < 0.4 ? 'HEALTH' : 'ENERGY';
                    this.loots.push(new Loot(Utils.rand(100, CONFIG.worldSize - 100), Utils.rand(100, CONFIG.worldSize - 100), type));
                }

                // Update Beams
                this.beams.forEach(b => {
                    b.life -= dt;
                    // Beam Damage
                    Game.entities.forEach(e => {
                        if (e === b.owner) return;
                        // Distancia ponto a reta
                        const proj = Game.projectPointToLine(e.pos, b.start, b.dir);
                        if (proj.dist < b.width / 2 + e.radius && proj.t > 0) {
                            e.takeDamage(150 * dt); // DPS alto
                        }
                    });
                });
                this.beams = this.beams.filter(b => b.life > 0);

                // Update Smokes
                this.smokes.forEach(s => s.life -= dt);
                this.smokes = this.smokes.filter(s => s.life > 0);

                // Camera Follow
                const screenCenter = new Vector2(this.canvas.width / 2, this.canvas.height / 2);
                const targetCam = this.player.pos.sub(screenCenter);
                this.camera.pos.x += (targetCam.x - this.camera.pos.x) * 0.1;
                this.camera.pos.y += (targetCam.y - this.camera.pos.y) * 0.1;

                // Update UI
                document.getElementById('alive-count').innerText = this.entities.length;
                document.getElementById('zone-display').innerText = Math.floor(this.zoneRadius / 10);
                document.getElementById('hp-text').innerText = Math.floor(this.player.hp);
                document.getElementById('hp-max').innerText = this.player.maxHp;
                document.getElementById('energy-text').innerText = Math.floor(this.player.energy);
                this.updateSkillUI();
            },

            draw() {
                // Clear
                this.ctx.fillStyle = '#2c3e50'; // Dark ground
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();

                // Shake
                const sx = (Math.random() - 0.5) * this.shake;
                const sy = (Math.random() - 0.5) * this.shake;
                this.ctx.translate(-this.camera.pos.x + sx, -this.camera.pos.y + sy);

                // Grid
                this.ctx.strokeStyle = '#34495e';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = 0; i < CONFIG.worldSize; i += 100) { this.ctx.moveTo(i, 0); this.ctx.lineTo(i, CONFIG.worldSize); this.ctx.moveTo(0, i); this.ctx.lineTo(CONFIG.worldSize, i); }
                this.ctx.stroke();

                // Zone
                this.ctx.fillStyle = 'rgba(231, 76, 60, 0.2)'; // Zona vermelha perigo
                this.ctx.beginPath();
                this.ctx.rect(-1000, -1000, CONFIG.worldSize + 2000, CONFIG.worldSize + 2000); // Mundo todo
                this.ctx.arc(CONFIG.worldSize / 2, CONFIG.worldSize / 2, this.zoneRadius, 0, Math.PI * 2, true); // Buraco no meio
                this.ctx.fill();
                this.ctx.strokeStyle = 'red'; this.ctx.lineWidth = 5; this.ctx.stroke();

                // ------------------------------------
                // Y-SORTING RENDER PIPELINE
                // ------------------------------------
                let renderList = [
                    ...this.entities,
                    ...this.walls,
                    ...this.particles,
                    ...this.projectiles,
                    ...this.loots
                ];

                // Ordena por Y. Para paredes, usa a base inferior (y + h).
                renderList.sort((a, b) => {
                    const ay = (a instanceof Wall) ? a.pos.y + a.h : a.pos.y;
                    const by = (b instanceof Wall) ? b.pos.y + b.h : b.pos.y;
                    return ay - by;
                });

                // Desenha Smokes (Fundo)
                this.smokes.forEach(s => {
                    this.ctx.fillStyle = `rgba(100,100,100,${s.life / 3})`;
                    this.ctx.beginPath(); this.ctx.arc(s.pos.x, s.pos.y, s.r, 0, Math.PI * 2); this.ctx.fill();
                });

                // Desenha Objetos Ordenados
                renderList.forEach(obj => obj.draw(this.ctx));

                // Desenha Beams (Kamehameha - Por cima de tudo)
                this.beams.forEach(b => {
                    this.ctx.strokeStyle = b.color;
                    this.ctx.lineWidth = b.width * (0.5 + Math.random() * 0.5); // Flicker effect
                    this.ctx.lineCap = 'round';
                    this.ctx.shadowBlur = 20; this.ctx.shadowColor = b.color;
                    this.ctx.beginPath();
                    const end = b.start.add(b.dir.mult(1000));
                    this.ctx.moveTo(b.start.x, b.start.y - 15); // Sai do peito
                    this.ctx.lineTo(end.x, end.y - 15);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                });

                this.ctx.restore();
            },

            // --- Helpers ---
            spawnProjectile(owner, pos, dir, dmg) {
                this.projectiles.push(new Projectile(owner, pos, dir, dmg));
            },
            addParticle(x, y, color) {
                this.particles.push(new Particle(x, y, color));
            },
            createExplosion(x, y, count, color) {
                for (let i = 0; i < count; i++) this.addParticle(x, y, color);
            },
            checkWall(x, y, r) {
                for (let w of this.walls) {
                    // AABB vs Circle Check (Simplificado)
                    if (x > w.pos.x - r && x < w.pos.x + w.w + r &&
                        y > w.pos.y - r && y < w.pos.y + w.h + r) return true;
                }
                return false;
            },
            checkAreaDamage(attacker, pos, radius, damage) {
                this.entities.forEach(e => {
                    if (e === attacker || e.dead) return;
                    if (e.pos.dist(pos) < radius + e.radius) {
                        e.takeDamage(damage);
                        if (e.dead && attacker === this.player) this.kills++;
                    }
                });
            },
            getNearestEnemy(bot) {
                let nearest = null; let minD = Infinity;
                this.entities.forEach(e => {
                    if (e === bot || e.dead) return;
                    const d = bot.pos.dist(e.pos);
                    if (d < minD) { minD = d; nearest = e; }
                });
                return nearest;
            },
            projectPointToLine(pt, v1, dir) { // Helper matem√°tica
                const w = pt.sub(v1);
                const t = (w.x * dir.x + w.y * dir.y); // Dot
                const proj = w.sub(dir.mult(t)); // Rejei√ß√£o
                return { dist: proj.mag(), t: t };
            },
            showGameOver() {
                document.getElementById('game-over').style.display = 'block';
                const h1 = document.querySelector('#game-over h1');
                h1.innerText = 'GAME OVER';
                h1.style.color = '#e74c3c';
                document.getElementById('go-rank').innerText = `Rank #${this.entities.length + 1}`;
                document.getElementById('go-kills').innerText = `Kills: ${this.kills}`;
            },

            showVictory() {
                document.getElementById('game-over').style.display = 'block';
                const h1 = document.querySelector('#game-over h1');
                h1.innerText = 'VICTORY ROYALE!';
                h1.style.color = '#f1c40f';
                document.getElementById('go-rank').innerText = `#1 WINNER`;
                document.getElementById('go-kills').innerText = `Kills: ${this.kills}`;
                Audio.sfxVictory();
            },

            // --- UI Builders ---
            buildSkillBar() {
                const slots = [
                    { key: 'M1', icon: '‚öîÔ∏è', id: 'atk' },
                    { key: 'M2', icon: this.player.config.icon, id: 'skill' },
                    { key: 'SPC', icon: 'üëü', id: 'dash' }
                ];
                const container = document.getElementById('skill-bar');
                container.innerHTML = slots.map(s => `
            <div class="skill-slot" id="slot-${s.id}">
                <div class="icon">${s.icon}</div>
                <div class="cooldown"></div>
                <div class="key">${s.key}</div>
            </div>
        `).join('');
            },
            updateSkillUI() {
                const setCD = (id, cur, max) => {
                    const el = document.querySelector(`#slot-${id} .cooldown`);
                    if (el) el.style.height = `${(cur / max) * 100}%`;
                };
                setCD('atk', this.player.attackCd, 0.4);
                setCD('skill', this.player.skillCd, this.player.config.skillCd);
                setCD('dash', this.player.dashCd, 3.0);
            }
        };

        // --- Input Handling ---
        window.addEventListener('keydown', e => Input.keys[e.key] = true);
        window.addEventListener('keyup', e => Input.keys[e.key] = false);
        window.addEventListener('mousedown', e => {
            if (e.button === 0) Input.mouseLeft = true;
            if (e.button === 2) Input.mouseRight = true;
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 0) Input.mouseLeft = false;
            if (e.button === 2) Input.mouseRight = false;
        });
        window.addEventListener('mousemove', e => {
            Input.mouse.x = e.clientX; Input.mouse.y = e.clientY;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('resize', () => Game.resize());

        // --- Setup Class Selection ---
        const heroList = document.getElementById('hero-list');
        Object.keys(CONFIG.heroes).forEach(key => {
            const h = CONFIG.heroes[key];
            const el = document.createElement('div');
            el.className = 'hero-card';
            el.innerHTML = `
        <div class="hero-icon" style="background:${h.color}; display:flex; align-items:center; justify-content:center; font-size:40px;">${h.icon}</div>
        <h3>${h.name}</h3>
        <p style="font-size:12px; color:#aaa; margin-top:5px;">${h.desc}</p>
    `;
            el.onclick = () => Game.init(key);
            heroList.appendChild(el);
        });

    </script>
</body>

</html>