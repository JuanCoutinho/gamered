<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IsoCity: Zombie Survival</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
            background-color: #111;
        }

        /* UI Visual */
        .glass {
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: white;
        }

        .build-card {
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .build-card:hover {
            transform: translateY(-4px);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .build-card.active {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.15);
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.2);
        }

        /* Animações */
        .badge-pop {
            animation: slideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes pulse-danger {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .horde-active #timer-bar {
            animation: pulse-danger 1s infinite;
            background: #ef4444;
        }

        /* Scrollbar Oculta */
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>

<body>

    <!-- TELA DE START -->
    <div id="start-screen"
        class="fixed inset-0 z-50 bg-slate-900 flex flex-col items-center justify-center text-white bg-[url('https://images.unsplash.com/photo-1509248961158-e54f6934749c?q=80&w=1920&auto=format&fit=crop')] bg-cover bg-center">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-md"></div>
        <div class="relative z-10 text-center">
            <h1
                class="text-7xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-emerald-600 drop-shadow-2xl">
                ZOMBIE CITY</h1>
            <p class="mb-10 text-gray-300 text-xl tracking-[0.3em] uppercase">Sobreviva. Explore. Construa.</p>
            <button onclick="startGame()"
                class="px-10 py-4 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-xl shadow-[0_0_30px_rgba(74,222,128,0.4)] transition-all transform hover:scale-105 flex items-center gap-3 border border-white/20">
                <i class="fas fa-biohazard"></i> INICIAR SOBREVIVÊNCIA
            </button>
        </div>
    </div>

    <!-- HUD -->
    <div class="absolute top-0 left-0 w-full p-4 z-30 flex justify-between pointer-events-none">
        <!-- Stats -->
        <div class="glass rounded-2xl px-5 py-3 flex gap-8 pointer-events-auto">
            <div>
                <div class="text-[10px] text-gray-400 font-bold tracking-widest">SUPRIMENTOS</div>
                <div class="text-2xl font-bold text-emerald-400 flex items-center gap-2">
                    <i class="fas fa-box"></i> <span id="ui-money">5,000</span>
                </div>
            </div>
            <div>
                <div class="text-[10px] text-gray-400 font-bold tracking-widest">COMIDA</div>
                <div class="text-2xl font-bold text-orange-400 flex items-center gap-2">
                    <i class="fas fa-hamburger"></i> <span id="ui-food">100</span>
                </div>
            </div>
            <div>
                <div class="text-[10px] text-gray-400 font-bold tracking-widest">ÁGUA</div>
                <div class="text-2xl font-bold text-cyan-400 flex items-center gap-2">
                    <i class="fas fa-tint"></i> <span id="ui-water">100</span>
                </div>
            </div>
            <div>
                <div class="text-[10px] text-gray-400 font-bold tracking-widest">SOBREVIVENTES</div>
                <div class="text-2xl font-bold text-blue-400 flex items-center gap-2">
                    <i class="fas fa-users"></i> <span id="ui-pop">0</span>
                </div>
            </div>
        </div>

        <!-- Relógio -->
        <div class="glass rounded-2xl p-3 px-6 pointer-events-auto flex items-center gap-4">
            <div class="text-right">
                <div class="text-[10px] text-gray-400 font-bold tracking-widest">DIA <span id="ui-day">1</span></div>
                <div id="ui-time" class="font-mono text-2xl font-bold text-white">08:00</div>
            </div>
            <div id="day-night-icon" class="w-4 h-4 rounded-full bg-yellow-400 shadow-[0_0_15px_yellow]"></div>
        </div>
    </div>

    <!-- BARRA DE HORDA -->
    <div class="absolute top-24 left-1/2 transform -translate-x-1/2 w-[500px] max-w-[90%] z-20">
        <div class="flex justify-between text-xs font-bold text-white mb-1 drop-shadow-md px-1">
            <span id="wave-status-text" class="text-red-400 tracking-widest uppercase animate-pulse">Horda se
                aproximando</span>
            <span id="ui-timer" class="font-mono">60s</span>
        </div>
        <div class="w-full h-2 bg-black/50 rounded-full overflow-hidden border border-white/10 backdrop-blur-sm">
            <div id="timer-bar" class="h-full bg-red-600 w-full transition-all duration-1000 linear"></div>
        </div>
        <div class="text-center mt-2">
            <span
                class="bg-red-900/80 text-white px-3 py-0.5 rounded text-[10px] font-bold border border-red-500/30">HORDA
                <span id="ui-wave">1</span></span>
        </div>
    </div>

    <!-- NOTIFICAÇÕES -->
    <div id="badge-container" class="absolute top-36 right-4 w-72 flex flex-col gap-2 pointer-events-none z-40"></div>

    <!-- MENU DE CONSTRUÇÃO -->
    <div
        class="absolute bottom-6 left-1/2 transform -translate-x-1/2 w-full max-w-5xl px-4 z-30 pointer-events-none flex flex-col items-center gap-3">

        <!-- Categorias -->
        <div
            class="flex gap-2 pointer-events-auto bg-black/60 p-1 rounded-full backdrop-blur-lg border border-white/10">
            <button onclick="setCategory('survival')" id="tab-survival"
                class="px-6 py-2 rounded-full font-bold text-xs tracking-wider bg-green-600 text-white shadow-lg transition">
                <i class="fas fa-campground mr-1"></i> SOBREVIVÊNCIA
            </button>
            <button onclick="setCategory('city')" id="tab-city"
                class="px-6 py-2 rounded-full font-bold text-xs tracking-wider text-gray-400 hover:text-white transition">
                <i class="fas fa-city mr-1"></i> CIDADE
            </button>
            <button onclick="setCategory('defense')" id="tab-defense"
                class="px-6 py-2 rounded-full font-bold text-xs tracking-wider text-gray-400 hover:text-white transition">
                <i class="fas fa-shield-alt mr-1"></i> DEFESA
            </button>
            <button onclick="setCategory('heroes')" id="tab-heroes"
                class="px-6 py-2 rounded-full font-bold text-xs tracking-wider text-gray-400 hover:text-white transition">
                <i class="fas fa-star mr-1"></i> HERÓIS
            </button>
        </div>

        <!-- Items -->
        <div class="glass w-full rounded-2xl p-3 pointer-events-auto">
            <div id="build-container" class="flex gap-2 justify-center min-w-max overflow-x-auto pb-1 scrollbar-hide">
                <!-- Items JS -->
            </div>
        </div>
    </div>

    <!-- CANVAS -->
    <div id="canvas-container" class="absolute inset-0 z-0 bg-black"></div>

    <script>
        // --- SOUND SYSTEM ---
        const SOUNDS = {
            shoot: 'https://assets.mixkit.co/active_storage/sfx/212/212-preview.mp3', // Laser/Retro shot
            build: 'https://assets.mixkit.co/active_storage/sfx/2578/2578-preview.mp3', // Pop/Build
            zombie: 'https://assets.mixkit.co/active_storage/sfx/419/419-preview.mp3', // Monster groan
            collect: 'https://assets.mixkit.co/active_storage/sfx/2019/2019-preview.mp3', // Coin/Ding
            explosion: 'https://assets.mixkit.co/active_storage/sfx/1698/1698-preview.mp3', // Explosion
            hit: 'https://assets.mixkit.co/active_storage/sfx/212/212-preview.mp3' // Hit (reuse shot for now)
        };

        const SoundManager = {
            play: (name) => {
                const audio = new Audio(SOUNDS[name]);
                audio.volume = 0.3;
                // Pitch Variation (0.9 - 1.1)
                audio.playbackRate = 0.9 + Math.random() * 0.2;
                // Preserves pitch if browser supports (optional, usually we want pitch change for effect)
                // audio.preservesPitch = false; 
                audio.play().catch(e => console.log("Audio blocked:", e));
            }
        };

        // --- CONFIGURAÇÃO ---
        const GRID_SIZE = 60; // Expanded Map
        const VISIBLE_RADIUS = 10; // Expanded View
        const TILE_SIZE = 10;
        const WAVE_TIME = 120;

        // Paleta de Cores "Voxel"
        const PALETTE = {
            grass: 0x4ade80, grassDark: 0x22c55e,
            sand: 0xfde047, sandDark: 0xeab308,
            water: 0x38bdf8, waterDark: 0x0ea5e9,
            stone: 0x94a3b8, snow: 0xf8fafc,
            wood: 0x78350f, woodLight: 0xb45309,
            wall: 0xe2e8f0, roof: 0xef4444,
            zombie: 0x84cc16, skin: 0xfca5a5,
            metal: 0x64748b, gold: 0xfacc15
        };

        // Definição de Construções
        const BUILDINGS = {
            'cursor': { cat: 'tools', name: 'Cancelar', cost: 0, icon: 'fa-mouse-pointer', color: 'gray-500', desc: 'Limpar seleção' },
            'bulldoze': { cat: 'tools', name: 'Demolir', cost: 10, icon: 'fa-eraser', color: 'red-500' },

            // Sobrevivência / Exploração
            'explorer': { cat: 'survival', name: 'Cabana Explorador', cost: 300, hp: 200, icon: 'fa-map-marked-alt', color: 'amber-700', desc: 'Expande o mapa.' },
            'farm': { cat: 'survival', name: 'Fazenda', cost: 200, hp: 150, food: 10, icon: 'fa-wheat', color: 'yellow-500', desc: 'Gera comida.' },
            'lumber': { cat: 'survival', name: 'Lenhador', cost: 150, hp: 150, income: 10, icon: 'fa-axe', color: 'amber-900', desc: 'Gera recursos.' },
            'fishing': { cat: 'survival', name: 'Pesca', cost: 250, hp: 150, food: 15, icon: 'fa-fish', color: 'blue-400', desc: 'Pesca (Água)' },
            'water_pump': { cat: 'survival', name: 'Bomba D\'água', cost: 400, hp: 300, icon: 'fa-faucet', color: 'cyan-600', desc: 'Água potável' },

            // Cidade
            'road': { cat: 'city', name: 'Estrada', cost: 10, hp: 100, icon: 'fa-road', color: 'gray-500' },
            'house': { cat: 'city', name: 'Abrigo', cost: 150, hp: 200, pop: 4, icon: 'fa-home', color: 'blue-500', desc: '+4 Pessoas' },
            'lamp': { cat: 'city', name: 'Poste', cost: 50, hp: 50, light: true, icon: 'fa-lightbulb', color: 'yellow-300', desc: 'Luz noturna.' },
            'factory': { cat: 'city', name: 'Fábrica', cost: 800, hp: 600, income: 50, icon: 'fa-industry', color: 'slate-600', desc: 'Gera suprimentos' },
            'hospital': { cat: 'city', name: 'Hospital', cost: 1200, hp: 800, icon: 'fa-heart-pulse', color: 'red-500', desc: 'Cura unidades' },
            'market': { cat: 'city', name: 'Mercado', cost: 600, hp: 400, icon: 'fa-store', color: 'orange-500', desc: 'Comércio' },
            'bench': { cat: 'city', name: 'Banco', cost: 20, hp: 50, icon: 'fa-chair', color: 'amber-800', desc: 'Decoração' },

            // Defesa
            'wall_v': { cat: 'defense', name: 'Muro (V)', cost: 50, hp: 1500, icon: 'fa-ruler-vertical', color: 'stone-600' },
            'wall_h': { cat: 'defense', name: 'Muro (H)', cost: 50, hp: 1500, icon: 'fa-ruler-horizontal', color: 'stone-600' },
            'turret': { cat: 'defense', name: 'Torre', cost: 500, hp: 400, dmg: 25, range: 30, rate: 800, icon: 'fa-chess-rook', color: 'slate-700' },
            'turret_gatling': { cat: 'defense', name: 'Gatling', cost: 1200, hp: 600, dmg: 10, range: 25, rate: 100, icon: 'fa-dharmachakra', color: 'yellow-800', desc: 'Tiro Rápido' },
            'barracks': { cat: 'defense', name: 'Base Militar', cost: 1000, hp: 1000, unit: 'soldier', icon: 'fa-person-rifle', color: 'green-800', desc: 'Treina Soldados' },
            'marine_camp': { cat: 'defense', name: 'Posto Fuzileiro', cost: 1500, hp: 800, unit: 'marine', icon: 'fa-person-military-rifle', color: 'green-600', desc: 'Fuzileiro (DPS)' },
            'tank_factory': { cat: 'defense', name: 'Fábrica Tanques', cost: 5000, hp: 2000, unit: 'tank', icon: 'fa-truck-monster', color: 'slate-900', desc: 'Tanque (AOE)' },
            'mine': { cat: 'defense', name: 'Mina Terrestre', cost: 100, hp: 10, icon: 'fa-land-mine-on', color: 'red-700', desc: 'Explode ao toque' },
            'bomb': { cat: 'defense', name: 'C4', cost: 200, hp: 10, icon: 'fa-bomb', color: 'black', desc: 'Detonação remota' },

            // Economia
            'gold_mine': { cat: 'city', name: 'Mina de Ouro', cost: 1500, hp: 500, icon: 'fa-gem', color: 'yellow-600', desc: 'Gera Ouro' },
            'factory': { cat: 'city', name: 'Fábrica', cost: 1000, hp: 300, icon: 'fa-industry', color: 'slate-500', desc: 'Gera Dinheiro' },

            // Heróis / Especiais
            'rick': { cat: 'heroes', name: 'Rick', cost: 1000, hp: 500, unit: 'rick', icon: 'fa-sheriff-badge', color: 'amber-600', desc: 'Líder (Magnum)' },
            'michonne': { cat: 'heroes', name: 'Michonne', cost: 1000, hp: 500, unit: 'michonne', icon: 'fa-khanda', color: 'purple-600', desc: 'Espadachim (Katana)' },
            'daryl': { cat: 'heroes', name: 'Daryl', cost: 1000, hp: 500, unit: 'daryl', icon: 'fa-bullseye', color: 'stone-500', desc: 'Caçador (Besta)' },
            'carol': { cat: 'heroes', name: 'Carol', cost: 1000, hp: 500, unit: 'carol', icon: 'fa-bomb', color: 'gray-400', desc: 'Explosivos (AOE)' },

            // Atualizações de Spawn
            'fishing': { cat: 'survival', name: 'Pesca', cost: 250, hp: 150, unit: 'fisherman', icon: 'fa-fish', color: 'blue-400', desc: 'Gera Comida (Pescador)' },
            'explorer': { cat: 'survival', name: 'Cabana Explorador', cost: 300, hp: 200, unit: 'sniper', icon: 'fa-map-marked-alt', color: 'amber-700', desc: 'Sniper (Longo Alcance)' },
        };

        let state = {
            money: 5000, food: 100, water: 100, population: 0, wave: 1,
            nextWaveTime: Date.now() + WAVE_TIME * 1000, isHorde: false,
            tool: null, category: 'survival', timeOfDay: 0.3, day: 1,
            gameStarted: false, // [NEW] Single Source of Truth Flag
            hordeNotificationShown: false, // [NEW] Anti-Spam Flag
            grid: [], entities: [], lights: [], particles: [], floatingTexts: [] // [NEW] Floating Texts
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 30;
        controls.minDistance = 30;
        controls.maxDistance = 200;

        const clock = new THREE.Clock(); // [NEW] Fix ReferenceError

        // Luzes
        const ambLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        scene.add(sunLight);

        // Grupos
        const worldGroup = new THREE.Group();
        const buildGroup = new THREE.Group();
        const entityGroup = new THREE.Group();
        const fxGroup = new THREE.Group();
        scene.add(worldGroup, buildGroup, entityGroup, fxGroup);

        // --- MATERIAIS ---
        const MATS = {
            grass: new THREE.MeshStandardMaterial({ color: PALETTE.grass }),
            sand: new THREE.MeshStandardMaterial({ color: PALETTE.sand }),
            water: new THREE.MeshStandardMaterial({ color: PALETTE.water, transparent: true, opacity: 0.8 }),
            stone: new THREE.MeshStandardMaterial({ color: PALETTE.stone }),
            wood: new THREE.MeshStandardMaterial({ color: PALETTE.wood }),
            wall: new THREE.MeshStandardMaterial({ color: PALETTE.wall }),
            roof: new THREE.MeshStandardMaterial({ color: PALETTE.roof }),
            road: new THREE.MeshStandardMaterial({ color: 0x333333 }),
            fog: new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.9 }),
            snow: new THREE.MeshStandardMaterial({ color: PALETTE.snow }),
            metal: new THREE.MeshStandardMaterial({ color: PALETTE.metal })
        };

        // --- GERAÇÃO DE MUNDO ---
        function initGrid() {
            const geo = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
            const cx = Math.floor(GRID_SIZE / 2);
            const cz = Math.floor(GRID_SIZE / 2);

            for (let x = 0; x < GRID_SIZE; x++) {
                state.grid[x] = [];
                for (let z = 0; z < GRID_SIZE; z++) {
                    // Calcular Bioma (Simples Perlin-like based on distance)
                    const dist = Math.sqrt((x - cx) ** 2 + (z - cz) ** 2);
                    let type = 'grass';

                    // Bioma Zones
                    const angle = Math.atan2(z - cz, x - cx);
                    if (dist > 15) {
                        if (angle > 0 && angle < 1.5) type = 'sand'; // Desert Quadrant
                        else if (angle < -1.5) type = 'snow'; // Snow Quadrant
                        else type = 'forest';
                    }

                    // Mesh
                    let mat = MATS.grass;
                    if (type === 'sand') mat = MATS.sand;
                    if (type === 'snow') mat = MATS.snow;

                    const mesh = new THREE.Mesh(geo, mat);
                    const px = (x * TILE_SIZE) - (GRID_SIZE * TILE_SIZE) / 2 + TILE_SIZE / 2;
                    const pz = (z * TILE_SIZE) - (GRID_SIZE * TILE_SIZE) / 2 + TILE_SIZE / 2;
                    mesh.position.set(px, -0.5, pz);
                    mesh.receiveShadow = true;

                    // Fog Logic (Névoa)
                    let isRevealed = dist < VISIBLE_RADIUS;

                    // Nuvem de névoa (Bloco preto em cima)
                    let fogMesh = null;
                    if (!isRevealed) {
                        fogMesh = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 5, TILE_SIZE), MATS.fog);
                        fogMesh.position.set(px, 2.5, pz);
                        worldGroup.add(fogMesh);
                    }

                    mesh.userData = { x, z, revealed: isRevealed, fog: fogMesh, biome: type };
                    worldGroup.add(mesh);
                    state.grid[x][z] = { type: null, mesh: mesh, data: null };

                    // Decorar se revelado
                    if (isRevealed) decorateTile(x, z, type, px, pz);
                }
            }
        }

        function decorateTile(x, z, biome, px, pz) {
            // Árvores aleatórias
            if (Math.random() > 0.85) {
                const tree = createTree();
                tree.position.set(px, 0, pz);
                buildGroup.add(tree);
                state.grid[x][z].type = 'decor';
                state.grid[x][z].data = { mesh: tree };
            }
            // Animais
            if (Math.random() > 0.97) spawnAnimal(px, pz);
        }

        function revealMap(cx, cz, radius) {
            let revealedCount = 0;
            for (let x = Math.max(0, cx - radius); x <= Math.min(GRID_SIZE - 1, cx + radius); x++) {
                for (let z = Math.max(0, cz - radius); z <= Math.min(GRID_SIZE - 1, cz + radius); z++) {
                    const cell = state.grid[x][z];
                    const tileData = cell.mesh.userData;

                    if (!tileData.revealed) {
                        tileData.revealed = true;
                        if (tileData.fog) {
                            // Animar saída da névoa
                            const f = tileData.fog;
                            let op = 1;
                            const fade = setInterval(() => {
                                op -= 0.1; f.scale.y -= 0.1;
                                if (op <= 0) { clearInterval(fade); worldGroup.remove(f); }
                            }, 30);
                        }

                        // Definir Bioma Aleatório ao revelar (Mantendo consistência com initGrid)
                        // const rand = Math.random();
                        // if (rand > 0.7) { tileData.biome = 'sand'; cell.mesh.material = MATS.sand; }
                        // else if (rand > 0.9) { tileData.biome = 'water'; cell.mesh.material = MATS.water; cell.mesh.position.y = -0.8; }
                        // else { tileData.biome = 'grass'; cell.mesh.material = MATS.grass; }

                        // Water gen (Lagos)
                        if (Math.random() > 0.95) {
                            tileData.biome = 'water';
                            cell.mesh.material = MATS.water;
                            cell.mesh.position.y = -0.8;
                        }

                        // Decorar
                        if (tileData.biome !== 'water' && Math.random() > 0.7) {
                            const px = cell.mesh.position.x;
                            const pz = cell.mesh.position.z;
                            decorateTile(x, z, tileData.biome, px, pz);
                        }
                        revealedCount++;
                    }
                }
            }
            if (revealedCount > 0) showBadge("Exploração", `${revealedCount} novas áreas descobertas!`, "fa-map");
        }

        // --- MODELOS ---

        function createTree() {
            const g = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), MATS.wood);
            trunk.position.y = 2;
            const leaves = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshStandardMaterial({ color: 0x166534 }));
            leaves.position.y = 5;
            g.add(trunk, leaves);
            g.castShadow = true;
            return g;
        }

        function createExplorerHut() {
            const g = new THREE.Group();
            // Cabana Rústica
            const base = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 8), MATS.wood);
            base.position.y = 2.5;
            const roof = new THREE.Mesh(new THREE.ConeGeometry(6, 4, 4), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
            roof.position.y = 6.5; roof.rotation.y = Math.PI / 4;
            const flag = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), MATS.wall);
            flag.position.set(3, 6, 3);
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            cloth.position.set(4, 7.5, 3);
            g.add(base, roof, flag, cloth);
            return g;
        }

        function createFarm() {
            const g = new THREE.Group();
            const ground = new THREE.Mesh(new THREE.BoxGeometry(9, 0.5, 9), new THREE.MeshStandardMaterial({ color: 0x5c4033 }));
            ground.position.y = 0.25;
            // Trigo
            for (let i = 0; i < 12; i++) {
                const w = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), new THREE.MeshStandardMaterial({ color: 0xfacc15 }));
                w.position.set((Math.random() - 0.5) * 7, 1.5, (Math.random() - 0.5) * 7);
                g.add(w);
            }
            // Celeiro pequeno
            const barn = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 4), new THREE.MeshStandardMaterial({ color: 0xb91c1c }));
            barn.position.set(-2, 2.5, -2);
            g.add(ground, barn);
            return g;
        }

        function createBarracks() {
            const g = new THREE.Group();
            const b1 = new THREE.Mesh(new THREE.BoxGeometry(9, 4, 5), new THREE.MeshStandardMaterial({ color: 0x3f6212 }));
            b1.position.set(0, 2, -2);
            const tower = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 4), MATS.stone);
            tower.position.set(2, 4, 2);
            g.add(b1, tower);
            return g;
        }

        function createHouse() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(7, 4, 7), MATS.wall);
            body.position.y = 2;
            const roof = new THREE.Mesh(new THREE.ConeGeometry(5, 3, 4), MATS.roof);
            roof.position.y = 5.5; roof.rotation.y = Math.PI / 4;
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 0.5), MATS.wood);
            door.position.set(0, 1.25, 3.6);
            g.add(body, roof, door);
            return g;
        }

        function createHeroModel(type) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), new THREE.MeshStandardMaterial({ color: 0x334155 })); // Base dark clothing
            body.position.y = 1;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xfca5a5 }));
            head.position.y = 2.4;
            g.add(body, head);

            if (type === 'rick') {
                // Sheriff Hat
                const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x78350f }));
                hatBrim.position.y = 2.8;
                const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0x78350f }));
                hatTop.position.y = 3.1;
                // Magnum
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1), new THREE.MeshStandardMaterial({ color: 0xc0c0c0 }));
                gun.position.set(0.6, 1.5, 0.5);
                g.add(hatBrim, hatTop, gun);
            } else if (type === 'michonne') {
                // Katana
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 2.5), new THREE.MeshStandardMaterial({ color: 0xe2e8f0 }));
                blade.position.set(0.7, 1.5, 0.5);
                blade.rotation.x = Math.PI / 4;
                // Bandana/Dreads (Visual abstract)
                const hair = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                hair.position.y = 2.45;
                g.add(blade, hair);
            } else if (type === 'daryl') {
                // Vest
                body.material.color.setHex(0x000000);
                // Crossbow
                const bow = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 0.2), new THREE.MeshStandardMaterial({ color: 0x3f3f46 }));
                bow.position.set(0, 1.5, 0.8);
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x3f3f46 }));
                stock.position.set(0, 1.5, 0.5);
                g.add(bow, stock);
            } else if (type === 'carol') {
                // Gray hair
                head.material.color.setHex(0xd1d5db);
                // Poncho/Coat
                body.material.color.setHex(0x4b5563);
                // Grenade/Weapon
                const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
                bomb.position.set(0.6, 1.5, 0.5);
                g.add(bomb);
            }

            return g;
        }

        // --- CONSTRUIR ---
        function build(x, z, type) {
            if (x < 0 || x >= GRID_SIZE || z < 0 || z >= GRID_SIZE) return;
            const cell = state.grid[x][z];
            const tileData = cell.mesh.userData;

            if (!tileData.revealed) return showBadge("Desconhecido", "Explore esta área primeiro!", "fa-eye-slash", "gray");
            if (tileData.biome === 'water' && type !== 'bulldoze') return showBadge("Água", "Não pode construir aqui.", "fa-water", "blue");

            if (type === 'bulldoze') {
                if (cell.data) {
                    buildGroup.remove(cell.data.mesh);
                    if (cell.data.light) scene.remove(cell.data.light);
                    cell.data = null; cell.type = null;
                    updateMoney(-10);
                    createParticles(cell.mesh.position, 0xaaaaaa, 10);
                }
                return;
            }

            if (cell.data) return showBadge("Ocupado", "Local inválido.", "fa-ban", "red");
            const spec = BUILDINGS[type];
            if (state.money < spec.cost) return showBadge("Sem Recursos", `$${spec.cost} necessários.`, "fa-coins", "red");

            let mesh;
            const pos = cell.mesh.position;

            // Selecionar Modelo
            if (type === 'explorer') {
                mesh = createExplorerHut();
                revealMap(x, z, 4); // Revela mapa ao construir!
            } else if (type === 'farm') {
                mesh = createFarm();
            } else if (type === 'barracks') {
                mesh = createBarracks();
            } else if (type === 'house') {
                mesh = createHouse();
            } else if (type === 'road') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE), MATS.road);
                mesh.position.y = 0.1;
            } else if (type === 'wall') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 6, 2), MATS.stone);
                mesh.position.y = 3;

            } else if (type === 'turret') {
                mesh = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(4, 6, 4), MATS.stone);
                base.position.y = 3;
                const head = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                head.position.y = 7;
                mesh.add(base, head);
            } else if (type === 'lamp') {
                mesh = new THREE.Group();
                const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 5), MATS.wood);
                p.position.y = 2.5;
                const l = new THREE.PointLight(0xffffaa, 1, 20);
                l.position.set(0, 5, 0);
                l.visible = false;
                state.lights.push(l);
                cell.light = l;
                mesh.add(p, l);
                scene.add(l); // Add light to scene not group
                l.position.add(pos);
            } else if (type === 'mine') {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.5), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                mesh.position.y = 0.2;
            } else if (type === 'bomb') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                b.position.y = 0.5;
                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                t.position.set(0, 1, 0);
                mesh.add(b, t);
            } else if (type === 'wall_v') {
                // [MODIFIED] Wall (V) with Pillars
                mesh = new THREE.Group();
                const w = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 10), MATS.stone);
                w.position.y = 4;
                // Pillars at ends
                const p1 = new THREE.Mesh(new THREE.BoxGeometry(3, 9, 3), MATS.stone);
                p1.position.set(0, 4.5, -4.5);
                const p2 = new THREE.Mesh(new THREE.BoxGeometry(3, 9, 3), MATS.stone);
                p2.position.set(0, 4.5, 4.5);
                mesh.add(w, p1, p2);
            } else if (type === 'wall_h') {
                // [MODIFIED] Wall (H) with Pillars
                mesh = new THREE.Group();
                const w = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 2), MATS.stone);
                w.position.y = 4;
                // Pillars at ends
                const p1 = new THREE.Mesh(new THREE.BoxGeometry(3, 9, 3), MATS.stone);
                p1.position.set(-4.5, 4.5, 0);
                const p2 = new THREE.Mesh(new THREE.BoxGeometry(3, 9, 3), MATS.stone);
                p2.position.set(4.5, 4.5, 0);
                mesh.add(w, p1, p2);
            } else if (type === 'turret_gatling') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), MATS.metal);
                b.position.y = 2;
                const h = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
                h.position.y = 4.5;
                mesh.add(b, h);
            } else if (['barracks', 'marine_camp', 'tank_factory'].includes(type)) {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), MATS.wood);
                mesh.position.y = 1;
            } else if (type === 'factory') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 8), MATS.metal);
                b.position.y = 3;
                const c1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 8), MATS.stone);
                c1.position.set(2, 4, 2);
                mesh.add(b, c1);
            } else if (type === 'hospital') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 6), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                b.position.y = 2.5;
                const cross1 = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 0.5), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                cross1.position.set(0, 6, 0);
                const cross2 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 0.5), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                cross2.position.set(0, 6, 0);
                mesh.add(b, cross1, cross2);
            } else if (type === 'market') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 6), MATS.wood);
                b.position.y = 2;
                const awning = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.5, 4), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                awning.position.set(0, 3.5, 2); awning.rotation.x = 0.2;
                mesh.add(b, awning);
            } else if (type === 'fishing') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), MATS.wood);
                b.position.y = 1.5;
                const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5), MATS.wood);
                rod.position.set(0, 3, 2); rod.rotation.x = Math.PI / 4;
                mesh.add(b, rod);
            } else if (type === 'water_pump') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 3), MATS.metal);
                b.position.y = 2;
                const pipe = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.3, 8, 20), MATS.metal);
                pipe.position.y = 3; pipe.rotation.x = Math.PI / 2;
                mesh.add(b, pipe);
            } else if (type === 'gold_mine') {
                mesh = new THREE.Group();
                const b = new THREE.Mesh(new THREE.BoxGeometry(6, 2, 6), MATS.stone);
                b.position.y = 1;
                const g = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 }));
                g.position.y = 3;
                mesh.add(b, g);
            } else if (type === 'bench') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 1.5), MATS.wood);
                mesh.position.y = 0.5;
            } else {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshStandardMaterial({ color: 0xff00ff }));
                mesh.position.y = 2.5;
            }

            mesh.position.x = pos.x;
            mesh.position.z = pos.z;
            if (type !== 'road' && type !== 'mine') mesh.castShadow = true;

            // Animação
            mesh.scale.set(0, 0, 0);
            let s = 0;
            const anim = setInterval(() => {
                s += 0.1; mesh.scale.set(s, s, s);
                if (s >= 1) clearInterval(anim);
            }, 20);

            buildGroup.add(mesh);
            cell.type = type;
            // [NEW] Production Data
            let prodData = {};
            if (type === 'farm') prodData = { prodRate: 5000, prodType: 'food', prodAmount: 10 };
            if (type === 'lumber') prodData = { prodRate: 5000, prodType: 'money', prodAmount: 10 };
            if (type === 'factory') prodData = { prodRate: 5000, prodType: 'money', prodAmount: 75 }; // Buffed
            if (type === 'fishing') prodData = { prodRate: 5000, prodType: 'food', prodAmount: 15 };
            if (type === 'gold_mine') prodData = { prodRate: 8000, prodType: 'money', prodAmount: 100 };
            if (type === 'water_pump') prodData = { prodRate: 4000, prodType: 'water', prodAmount: 20 };

            cell.data = { mesh: mesh, hp: spec.hp, light: cell.light, ...prodData };

            updateMoney(-spec.cost);
            if (spec.pop) updatePop(spec.pop);
            // if (spec.food) updateFood(spec.food); // Removed instant food, now production
            if (spec.unit) {
                // Spawn outside the building to avoid being stuck
                spawnEntity(spec.unit, pos.x + 3, pos.z + 3);
            }
            if (type === 'house') spawnEntity('citizen', pos.x + 2, pos.z + 2); // Casa spawna gente

            createParticles(pos, 0xffffff, 8);
            SoundManager.play('build');
        }

        // [NEW] Floating Text Helper
        function showFloatingText(text, pos, color) {
            const div = document.createElement('div');
            div.innerText = text;
            div.style.position = 'absolute';
            div.style.color = color;
            div.style.fontWeight = 'bold';
            div.style.fontSize = '12px';
            div.style.pointerEvents = 'none';
            div.style.textShadow = '1px 1px 0 #000';
            document.body.appendChild(div);

            // Project 3D pos to 2D screen
            const p = pos.clone();
            p.y += 2;
            p.project(camera);
            const x = (p.x * .5 + .5) * window.innerWidth;
            const y = (-(p.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;

            // Animate
            let life = 1.0;
            const anim = setInterval(() => {
                life -= 0.02;
                div.style.opacity = life;
                div.style.top = `${parseFloat(div.style.top) - 1}px`;
                if (life <= 0) {
                    clearInterval(anim);
                    div.remove();
                }
            }, 30);
        }

        // --- ENTIDADES (Zumbis, Pessoas, Animais) ---

        function spawnEntity(type, x, z) {
            const g = new THREE.Group();
            let speed = 0.05;
            let hp = 10;
            let range = 0; // 0 = melee

            if (type === 'citizen') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x3b82f6 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
                body.position.y = 1; head.position.y = 2.4;
                g.add(body, head);
                speed = 0.03;
            } else if (type === 'fisherman') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x0ea5e9 })); // Blue
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
                const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), new THREE.MeshStandardMaterial({ color: 0x78350f }));
                rod.rotation.x = Math.PI / 4; rod.position.set(0.5, 2, 1);
                body.position.y = 1; head.position.y = 2.4;
                g.add(body, head, rod);
                speed = 0.02;
            } else if (type === 'sniper') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x3f6212 })); // Camo
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 3), new THREE.MeshStandardMaterial({ color: 0x000000 })); // Long gun
                gun.position.set(0.5, 1.5, 1);
                body.position.y = 1; head.position.y = 2.4;
                g.add(body, head, gun);
                hp = 100;
                speed = 0.05;
                range = 40;
            } else if (type === 'soldier') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), new THREE.MeshStandardMaterial({ color: 0x166534 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 })); // Capacete
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                body.position.y = 1; head.position.y = 2.4; gun.position.set(0.5, 1.5, 0.5);
                g.add(body, head, gun);
                hp = 50;
                speed = 0.06;
                range = 20;
            } else if (['rick', 'michonne', 'daryl', 'carol'].includes(type)) {
                const model = createHeroModel(type);
                g.add(model);
                hp = 500;
                speed = 0.07;
                if (type === 'rick') range = 25; // Magnum
                if (type === 'daryl') range = 40; // Crossbow (Sniper)
                if (type === 'carol') range = 15; // Grenade
                if (type === 'michonne') range = 2; // Melee
            } else if (type === 'zombie') {
                // Green (Weak)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x4d7c0f }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0x3f6212 }));
                const arms = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0x4d7c0f }));
                body.position.y = 1; head.position.y = 2.4; arms.position.set(0, 1.6, 0.5);
                g.add(body, head, arms);
                hp = 20 + (state.wave * 2); speed = 0.03;
            } else if (type === 'zombie_normal') {
                // Grey (Medium)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x6b7280 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0x374151 }));
                const arms = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0x6b7280 }));
                body.position.y = 1; head.position.y = 2.4; arms.position.set(0, 1.6, 0.5);
                g.add(body, head, arms);
                hp = 40 + (state.wave * 3); speed = 0.05;
            } else if (type === 'zombie_red') {
                // Red (Fast)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0xb91c1c }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0x7f1d1d }));
                const arms = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xb91c1c }));
                body.position.y = 1; head.position.y = 2.4; arms.position.set(0, 1.6, 0.5);
                g.add(body, head, arms);
                hp = 60 + (state.wave * 4); speed = 0.07;
            } else if (type === 'zombie_black') {
                // Black Ops (Tank)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                const arms = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                body.position.y = 1.1; head.position.y = 2.6; arms.position.set(0, 1.7, 0.5);
                g.add(body, head, arms);
                hp = 200 + (state.wave * 10); speed = 0.04;
            } else if (type === 'zombie_explosive') {
                // Yellow (Explosive)
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0xeab308 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({ color: 0xa16207 }));
                const arms = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xeab308 }));
                body.position.y = 1; head.position.y = 2.4; arms.position.set(0, 1.6, 0.5);
                g.add(body, head, arms);
                hp = 30 + (state.wave * 3); speed = 0.06;
            } else if (type === 'tank') {
                // Player Tank - 3x Scale
                const body = new THREE.Mesh(new THREE.BoxGeometry(7.5, 4.5, 12), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
                const turret = new THREE.Mesh(new THREE.BoxGeometry(4.5, 3, 6), new THREE.MeshStandardMaterial({ color: 0x334155 }));
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 9), new THREE.MeshStandardMaterial({ color: 0x0f172a }));
                barrel.rotation.x = Math.PI / 2; barrel.position.z = 4.5;
                body.position.y = 2.25; turret.position.y = 6; turret.add(barrel);
                g.add(body, turret);
                hp = 3000; speed = 0.05; range = 30;

                // Spawn Check
                let valid = false;
                let attempts = 0;
                while (!valid && attempts < 10) {
                    if (PhysicsSystem.isFree(g.position)) {
                        valid = true;
                    } else {
                        g.position.x = x + (Math.random() - 0.5) * 20;
                        g.position.z = z + (Math.random() - 0.5) * 20;
                        attempts++;
                    }
                }
            } else if (type === 'marine') {
                // Fuzileiro
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2, 1.1), new THREE.MeshStandardMaterial({ color: 0x15803d }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                body.position.y = 1; head.position.y = 2.4; gun.position.set(0.3, 1.5, 0.5);
                g.add(body, head, gun);
                hp = 80; speed = 0.06; range = 18;
            } else if (type === 'cow') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 3), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                const spots = new THREE.Mesh(new THREE.BoxGeometry(2.1, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                body.position.y = 1; head.position.set(0, 2, 1.5); spots.position.y = 1;
                g.add(body, spots, head);
                speed = 0.01;
            }

            g.position.set(x, 0, z);
            g.castShadow = true;
            entityGroup.add(g);
            const e = { mesh: g, type, hp, maxHp: hp, speed, range, cooldown: 0 };

            // [NEW] Zombies target center immediately
            if (type.includes('zombie')) {
                e.target = { mesh: { position: new THREE.Vector3(0, 0, 0) }, type: 'center' };
            }

            state.entities.push(e);
        }

        function spawnAnimal(x, z) {
            spawnEntity(Math.random() > 0.5 ? 'cow' : 'sheep', x, z);
        }

        function spawnHorde(type = 'zombie') {
            const angle = Math.random() * Math.PI * 2;
            const r = 45; // Edge of map
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            spawnEntity(type, x, z);
        }



        // --- PHYSICS SYSTEM (NEW) ---
        const PhysicsSystem = {
            // Retorna o AABB da entidade ou posição
            getBox: (pos, size = 0.8) => {
                return {
                    minX: pos.x - size / 2, maxX: pos.x + size / 2,
                    minZ: pos.z - size / 2, maxZ: pos.z + size / 2
                };
            },

            // Verifica intersecção entre dois AABBs
            checkOverlap: (box1, box2) => {
                return (box1.minX <= box2.maxX && box1.maxX >= box2.minX &&
                    box1.minZ <= box2.maxZ && box1.maxZ >= box2.minZ);
            },

            // Verifica se a posição é válida (não colide com sólidos)
            isFree: (pos, ignoreEntity = null) => {
                // 1. Limites do Mundo
                const limit = (GRID_SIZE * TILE_SIZE) / 2;
                if (pos.x < -limit || pos.x > limit || pos.z < -limit || pos.z > limit) return false;

                // 2. Colisão com Grid (Construções)
                const gx = Math.round((pos.x + limit - TILE_SIZE / 2) / TILE_SIZE);
                const gz = Math.round((pos.z + limit - TILE_SIZE / 2) / TILE_SIZE);

                if (gx >= 0 && gx < GRID_SIZE && gz >= 0 && gz < GRID_SIZE) {
                    const cell = state.grid[gx][gz];
                    // Lista de construções sólidas
                    const solids = ['wall', 'wall_v', 'wall_h', 'turret', 'turret_gatling', 'barracks', 'marine_camp', 'tank_factory', 'house', 'factory', 'hospital', 'market', 'water_pump', 'fishing', 'explorer', 'farm', 'gold_mine'];
                    if (cell.type && solids.includes(cell.type)) {
                        // Colisão simples: Se o centro da entidade entrar na célula ocupada
                        // Refinamento: Verificar AABB da célula vs AABB da entidade
                        let cellBox = {
                            minX: (gx * TILE_SIZE) - limit, maxX: (gx * TILE_SIZE) - limit + TILE_SIZE,
                            minZ: (gz * TILE_SIZE) - limit, maxZ: (gz * TILE_SIZE) - limit + TILE_SIZE
                        };

                        // [NEW] Custom Hitboxes for Walls
                        if (cell.type === 'wall_v') {
                            // Thinner on X (Width 3 for Pillars)
                            const center = (cellBox.minX + cellBox.maxX) / 2;
                            cellBox.minX = center - 1.5; cellBox.maxX = center + 1.5;
                        } else if (cell.type === 'wall_h') {
                            // Thinner on Z (Width 3 for Pillars)
                            const center = (cellBox.minZ + cellBox.maxZ) / 2;
                            cellBox.minZ = center - 1.5; cellBox.maxZ = center + 1.5;
                        }

                        const entBox = PhysicsSystem.getBox(pos);
                        if (PhysicsSystem.checkOverlap(cellBox, entBox)) return false;
                    }
                    // Água é sólida para não-barcos (todos por enquanto)
                    if (cell.mesh.userData.biome === 'water' && cell.type !== 'fishing') { // Fishing allows standing on deck? No, simplified.
                        // Check biome directly from mesh data is tricky if we don't have grid ref easily, but we do here.
                        // Actually, let's trust the grid check.
                    }
                }

                // 3. Colisão com outras Entidades (Soft Collision / Push)
                // Opcional para performance: apenas checar se muito perto
                /*
                for (let e of state.entities) {
                    if (e === ignoreEntity || e.hp <= 0) continue;
                    if (pos.distanceTo(e.mesh.position) < 0.8) return false;
                }
                */
                return true;
            },

            // Tenta mover a entidade. Se colidir, desliza (slide) ou para.
            move: (entity, desiredDir, speed) => {
                const currentPos = entity.mesh.position.clone();
                const velocity = desiredDir.clone().multiplyScalar(speed);
                const nextPos = currentPos.clone().add(velocity);

                // Tentativa 1: Movimento completo
                if (PhysicsSystem.isFree(nextPos, entity)) {
                    entity.mesh.position.copy(nextPos);
                    return true;
                }

                // Tentativa 2: Slide X (Zera Z)
                const nextPosX = currentPos.clone().add(new THREE.Vector3(velocity.x, 0, 0));
                if (Math.abs(velocity.x) > 0.001 && PhysicsSystem.isFree(nextPosX, entity)) {
                    entity.mesh.position.copy(nextPosX);
                    return true;
                }

                // Tentativa 3: Slide Z (Zera X)
                const nextPosZ = currentPos.clone().add(new THREE.Vector3(0, 0, velocity.z));
                if (Math.abs(velocity.z) > 0.001 && PhysicsSystem.isFree(nextPosZ, entity)) {
                    entity.mesh.position.copy(nextPosZ);
                    return true;
                }

                // Bloqueado
                return false;
            }
        };

        function updateEntities() {
            const center = new THREE.Vector3(0, 0, 0);

            state.entities.forEach((e, i) => {
                if (e.hp <= 0) return;

                // IA Zumbi
                if (e.type.includes('zombie')) {
                    // Achar alvo (humano ou construção)
                    if (!e.target || e.target.hp <= 0) {
                        // Buscar humano mais próximo
                        let closeDist = 9999;
                        state.entities.forEach(other => {
                            if (['citizen', 'soldier', 'rick', 'michonne', 'daryl', 'carol', 'fisherman', 'sniper', 'tank', 'marine'].includes(other.type)) {
                                const d = e.mesh.position.distanceTo(other.mesh.position);
                                if (d < closeDist) { closeDist = d; e.target = other; }
                            }
                        });
                        // Se não achar humano, vai pro centro (atacando prédios no caminho)
                        if (!e.target) e.target = { mesh: { position: center }, type: 'center' };
                    }

                    // Mover
                    const dir = new THREE.Vector3().subVectors(e.target.mesh.position, e.mesh.position).normalize();
                    // [MODIFIED] Use PhysicsSystem
                    PhysicsSystem.move(e, dir, e.speed);
                    e.mesh.lookAt(e.target.mesh.position);

                    // Atacar
                    if (e.target.type !== 'center' && e.mesh.position.distanceTo(e.target.mesh.position) < 2) {
                        if (Date.now() > e.cooldown) {
                            e.target.hp -= (e.type === 'zombie_black' ? 20 : 5); // Tank hits harder
                            createParticles(e.target.mesh.position, 0xff0000, 2);
                            e.cooldown = Date.now() + 1000;

                            // Explosive Zombie Logic
                            if (e.type === 'zombie_explosive') {
                                e.hp = 0; // Die and explode
                                createParticles(e.mesh.position, 0xeab308, 20);
                                SoundManager.play('explosion');
                                state.entities.forEach(ent => {
                                    if (ent.mesh.position.distanceTo(e.mesh.position) < 5) ent.hp -= 50;
                                });
                            }
                        }
                    } else {
                        // Checar colisão com prédio (Attack wall)
                        const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(e.mesh.quaternion);
                        const next = e.mesh.position.clone().add(fwd);
                        const limit = (GRID_SIZE * TILE_SIZE) / 2;
                        const gx = Math.round((next.x + limit - TILE_SIZE / 2) / TILE_SIZE);
                        const gz = Math.round((next.z + limit - TILE_SIZE / 2) / TILE_SIZE);
                        if (state.grid[gx] && state.grid[gx][gz] && state.grid[gx][gz].data) {
                            const b = state.grid[gx][gz];
                            if (Date.now() > e.cooldown) {
                                b.data.hp -= (e.type === 'zombie_black' ? 40 : 10);
                                createParticles(next, 0xaaaaaa, 3);
                                e.cooldown = Date.now() + 1000;

                                if (e.type === 'zombie_explosive') {
                                    e.hp = 0; // Die and explode on wall
                                    createParticles(e.mesh.position, 0xeab308, 20);
                                    SoundManager.play('explosion');
                                    // Damage wall significantly
                                    b.data.hp -= 200;
                                }

                                if (b.data.hp <= 0) {
                                    buildGroup.remove(b.data.mesh);
                                    if (b.data.light) scene.remove(b.data.light);
                                    b.type = null; b.data = null;
                                    createParticles(next, 0x555555, 20);
                                    SoundManager.play('explosion');
                                }
                            }
                        }
                    }

                }
                // IA Cidadão/Soldado/Herois/Especiais/Tanque
                else if (['citizen', 'soldier', 'rick', 'michonne', 'daryl', 'carol', 'fisherman', 'sniper', 'tank', 'marine'].includes(e.type)) {
                    const isCombatUnit = !['citizen', 'fisherman'].includes(e.type);

                    // Fisherman Logic (Produce Food)
                    if (e.type === 'fisherman') {
                        if (!e.lastProd) e.lastProd = Date.now();
                        if (Date.now() - e.lastProd > 5000) {
                            e.lastProd = Date.now();
                            updateFood(5);
                            showFloatingText("+5 Food", e.mesh.position, 'cyan');
                        }
                    }

                    if (isCombatUnit) {
                        // Atacar zumbis
                        const zombie = state.entities.find(z => z.type.includes('zombie') && z.mesh.position.distanceTo(e.mesh.position) < (e.range || 20) && z.hp > 0);

                        if (zombie) {
                            e.mesh.lookAt(zombie.mesh.position);
                            if (Date.now() > e.cooldown) {
                                // Efeitos e Dano por Tipo
                                if (e.type === 'tank') {
                                    // Tank AOE
                                    createParticles(zombie.mesh.position, 0xff4500, 30);
                                    SoundManager.play('explosion');
                                    state.entities.forEach(ent => {
                                        if (ent.type.includes('zombie') && ent.mesh.position.distanceTo(zombie.mesh.position) < 5) {
                                            ent.hp -= 150;
                                        }
                                    });
                                    e.cooldown = Date.now() + 2000; // Slow fire
                                } else if (e.type === 'marine') {
                                    // Fast Fire
                                    const laser = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, e.mesh.position.distanceTo(zombie.mesh.position)), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                                    laser.position.copy(e.mesh.position).lerp(zombie.mesh.position, 0.5);
                                    laser.lookAt(zombie.mesh.position);
                                    fxGroup.add(laser); setTimeout(() => fxGroup.remove(laser), 30);
                                    SoundManager.play('shoot');
                                    zombie.hp -= 15;
                                    e.cooldown = Date.now() + 100; // Very fast
                                } else if (e.type === 'rick') {
                                    // Magnum: Knockback + High Dmg
                                    const laser = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, e.mesh.position.distanceTo(zombie.mesh.position)), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
                                    laser.position.copy(e.mesh.position).lerp(zombie.mesh.position, 0.5);
                                    laser.lookAt(zombie.mesh.position);
                                    fxGroup.add(laser); setTimeout(() => fxGroup.remove(laser), 100);
                                    SoundManager.play('shoot');

                                    zombie.hp -= 100; // One shot most
                                    // Knockback
                                    const push = new THREE.Vector3().subVectors(zombie.mesh.position, e.mesh.position).normalize().multiplyScalar(5);
                                    // [MODIFIED] Use Physics Check for Knockback
                                    if (PhysicsSystem.isFree(zombie.mesh.position.clone().add(push))) {
                                        zombie.mesh.position.add(push);
                                    }
                                    e.cooldown = Date.now() + 1000;
                                } else if (e.type === 'sniper') {
                                    // Sniper: High Dmg, Long Range
                                    const laser = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, e.mesh.position.distanceTo(zombie.mesh.position)), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                                    laser.position.copy(e.mesh.position).lerp(zombie.mesh.position, 0.5);
                                    laser.lookAt(zombie.mesh.position);
                                    fxGroup.add(laser); setTimeout(() => fxGroup.remove(laser), 200);
                                    SoundManager.play('shoot');
                                    zombie.hp -= 300; // One shot
                                    e.cooldown = Date.now() + 2000;
                                } else if (e.type === 'michonne') {
                                    // Katana: Melee
                                    if (e.mesh.position.distanceTo(zombie.mesh.position) < 3) {
                                        zombie.hp -= 80;
                                        createParticles(zombie.mesh.position, 0xff0000, 10);
                                        // Dash visual
                                        // [MODIFIED] Safe Dash
                                        const dashPos = zombie.mesh.position.clone();
                                        if (PhysicsSystem.isFree(dashPos)) e.mesh.position.lerp(dashPos, 0.2);
                                    } else {
                                        // Move closer if out of range but targeted
                                        const dir = new THREE.Vector3().subVectors(zombie.mesh.position, e.mesh.position).normalize();
                                        // [MODIFIED] Use Physics
                                        PhysicsSystem.move(e, dir, e.speed);
                                    }
                                    e.cooldown = Date.now() + 600;
                                } else if (e.type === 'daryl') {
                                    // Crossbow: Silent, Long range
                                    const arrow = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 1), new THREE.MeshBasicMaterial({ color: 0xaaaaaa }));
                                    arrow.position.copy(e.mesh.position).lerp(zombie.mesh.position, 0.5);
                                    arrow.lookAt(zombie.mesh.position);
                                    fxGroup.add(arrow); setTimeout(() => fxGroup.remove(arrow), 150);

                                    zombie.hp -= 60;
                                    e.cooldown = Date.now() + 1200;
                                } else if (e.type === 'carol') {
                                    // Grenade: AOE
                                    const grenade = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                                    grenade.position.copy(e.mesh.position);
                                    fxGroup.add(grenade);

                                    // Animate throw (fake)
                                    const targetPos = zombie.mesh.position.clone();
                                    let t = 0;
                                    const throwAnim = setInterval(() => {
                                        t += 0.1;
                                        grenade.position.lerp(targetPos, t);
                                        if (t >= 1) {
                                            clearInterval(throwAnim);
                                            fxGroup.remove(grenade);
                                            // Explosion
                                            createParticles(targetPos, 0xff4500, 20);
                                            SoundManager.play('explosion');
                                            // AOE Damage
                                            state.entities.forEach(ent => {
                                                if (ent.type.includes('zombie') && ent.mesh.position.distanceTo(targetPos) < 8) {
                                                    ent.hp -= 150;
                                                }
                                            });
                                        }
                                    }, 50);
                                    e.cooldown = Date.now() + 3000;
                                } else {
                                    // Soldier default
                                    const laser = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, e.mesh.position.distanceTo(zombie.mesh.position)), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                                    laser.position.copy(e.mesh.position).lerp(zombie.mesh.position, 0.5);
                                    laser.lookAt(zombie.mesh.position);
                                    fxGroup.add(laser); setTimeout(() => fxGroup.remove(laser), 50);
                                    zombie.hp -= 10;
                                    e.cooldown = Date.now() + 500;
                                }
                            }
                        }
                    }

                    // Andar aleatório (Patrulha) - Agora para TODOS (Soldados, Cidadãos, Pescadores, Tanques)
                    // Se não tiver alvo, escolhe um ponto aleatório
                    if (!e.target || e.mesh.position.distanceTo(e.target) < 1) {
                        // Tank Patrol: Slower, deliberate
                        e.target = new THREE.Vector3((Math.random() - 0.5) * 100, 0, (Math.random() - 0.5) * 100);
                    }
                    const dir = new THREE.Vector3().subVectors(e.target, e.mesh.position).normalize();

                    // [MODIFIED] Use Physics & Handle Collision
                    // For Tank, we might need to check a wider radius, but for now standard move.
                    const moved = PhysicsSystem.move(e, dir, e.speed);
                    if (!moved) {
                        // Se bloqueado, muda de alvo imediatamente
                        e.target = new THREE.Vector3((Math.random() - 0.5) * 100, 0, (Math.random() - 0.5) * 100);

                        // Tank Unstuck Logic
                        if (e.type === 'tank') {
                            e.mesh.rotation.y += Math.PI; // Turn around
                            e.mesh.position.add(dir.multiplyScalar(-2)); // Back up
                        }
                    }

                    e.mesh.lookAt(e.target);
                }
                // Animais
                else {
                    if (Math.random() > 0.99) e.mesh.rotation.y += Math.random();

                    // [MODIFIED] Use Physics & Handle Collision
                    const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(e.mesh.quaternion);
                    const moved = PhysicsSystem.move(e, fwd, e.speed);

                    if (!moved) {
                        // Se bater, gira 180 graus (ou aleatório)
                        e.mesh.rotation.y += Math.PI + (Math.random() - 0.5);
                    }
                }
            });

            // Limpeza
            for (let i = state.entities.length - 1; i >= 0; i--) {
                if (state.entities[i].hp <= 0) {
                    createParticles(state.entities[i].mesh.position, 0x990000, 5);
                    entityGroup.remove(state.entities[i].mesh);
                    if (state.entities[i].type === 'zombie') updateMoney(15); // Recompensa
                    else if (state.entities[i].type === 'citizen') {
                        updatePop(-1);
                        showBadge("Baixa", "Um cidadão morreu!", "fa-skull", "red");
                        if (cell.type && !(type === 'lamp' && cell.type === 'road')) {
                            showBadge("Ocupado", "Já existe algo aqui.", "fa-ban", "red");
                            return;
                        }
                    }
                    state.entities.splice(i, 1);
                }
            }
        }

        // --- PARTICULAS ---
        function createParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const mat = new THREE.MeshBasicMaterial({ color });
            for (let i = 0; i < count; i++) {
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(pos);
                m.position.x += (Math.random() - 0.5) * 2;
                m.position.y += Math.random() * 2;
                m.position.z += (Math.random() - 0.5) * 2;
                fxGroup.add(m);
                state.particles.push({ m, life: 1.0, vel: new THREE.Vector3((Math.random() - 0.5) * 0.1, Math.random() * 0.1, (Math.random() - 0.5) * 0.1) });
            }
        }

        // --- LOOT SYSTEM (NEW) ---
        const LootSystem = {
            items: [],

            spawn: (x, z, type = 'money') => {
                // Check for solids before spawning
                if (!PhysicsSystem.isFree(new THREE.Vector3(x, 0, z))) return;

                const g = new THREE.Group();

                // Visual do Loot
                let color = 0xffd700; // Gold
                if (type === 'food') color = 0xffaa00; // Food

                const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 }));
                box.position.y = 0.5;

                // Icone flutuante
                const icon = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                icon.position.y = 1.0;

                g.add(box, icon);
                g.position.set(x, 0, z);

                fxGroup.add(g);
                // [MODIFIED] Buffed Loot
                const val = type === 'money' ? 75 : 10; // Was 50
                LootSystem.items.push({ mesh: g, type, val, rot: Math.random() });
            },

            spawnRandom: (count = 5) => {
                for (let i = 0; i < count; i++) {
                    const x = (Math.random() - 0.5) * 100;
                    const z = (Math.random() - 0.5) * 100;
                    LootSystem.spawn(x, z, Math.random() > 0.5 ? 'money' : 'food');
                }
            },

            update: () => {
                const playerUnits = state.entities.filter(e => ['rick', 'michonne', 'daryl', 'carol', 'soldier', 'citizen'].includes(e.type));

                for (let i = LootSystem.items.length - 1; i >= 0; i--) {
                    const item = LootSystem.items[i];

                    // Animação
                    item.mesh.rotation.y += 0.05;
                    item.mesh.children[1].position.y = 1.0 + Math.sin(Date.now() * 0.005 + item.rot) * 0.2;

                    // Coleta via Click (Removido auto-coleta)
                }
            }
        };

        // --- GAME LOOP ---
        function updateLogic() {
            if (!state.gameStarted) return; // [NEW] Prevent logic before start

            // Ciclo Dia/Noite
            state.timeOfDay += 0.0003;
            if (state.timeOfDay > 1) { state.timeOfDay = 0; state.day++; document.getElementById('ui-day').innerText = state.day; }

            const t = state.timeOfDay;
            const isNight = t > 0.75 || t < 0.2;

            // Horda Noturna
            if (isNight && !state.isHorde) {
                if (state.nextWaveTime - Date.now() <= 0 && !state.hordeNotificationShown) {
                    state.isHorde = true;
                    state.hordeNotificationShown = true; // [NEW] Lock Notification
                    showBadge("Horda Noturna", "Zumbis estão vindo!", "fa-biohazard", "red");
                    document.body.classList.add("horde-active");
                    // Spawn loop
                    function spawnHorde(count, type = 'zombie') {
                        // [NEW] Simplified Radial Spawn (Darkness Logic)
                        // Spawns zombies far away (350-450 units) to ensure they come from the darkness
                        const MIN_RADIUS = 350;
                        const MAX_RADIUS = 450;

                        // Center is Player (or Camera Target, effectively 0,0 mostly but let's use 0,0 for base defense)
                        // User asked for "Centro = Jogador". Let's assume player is at 0,0 or find a player entity.
                        // Since it's an RTS, "Player" is the camera focus or the base. 
                        // The request says "x = player.x + ...". But we don't have a single 'player' entity variable easily accessible here 
                        // without searching. However, the base is at 0,0. Let's use 0,0 as the center for now as it's the "Colony".
                        const cx = 0;
                        const cz = 0;

                        for (let i = 0; i < count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = MIN_RADIUS + Math.random() * (MAX_RADIUS - MIN_RADIUS);

                            const x = cx + Math.cos(angle) * dist;
                            const z = cz + Math.sin(angle) * dist;

                            // Mutation Logic based on Day
                            let zType = 'zombie';
                            if (state.day >= 6 && state.day <= 12) zType = 'zombie';
                            else if (state.day >= 13 && state.day <= 20) zType = 'zombie_red';
                            else if (state.day >= 21) {
                                const r = Math.random();
                                if (r < 0.1) zType = 'zombie_black';
                                else if (r < 0.3) zType = 'zombie_explosive';
                                else zType = 'zombie_red';
                            } else {
                                zType = 'zombie';
                            }

                            if (type !== 'zombie') zType = type;

                            spawnEntity(zType, x, z);
                        }

                        // Removed SoundManager.play('zombie') here to avoid spam if called frequently
                    }
                    state.hordeInterval = setInterval(() => {
                        // [NEW] Optimization: Hard Limit
                        const zombieCount = state.entities.filter(e => e.type.includes('zombie')).length;
                        if (zombieCount >= 150) return;

                        // [NEW] Evolution System
                        let type = 'zombie'; // Default Green
                        const day = state.day;
                        const r = Math.random();

                        if (day >= 6 && day <= 12) {
                            if (r > 0.7) type = 'zombie_normal';
                        } else if (day >= 13 && day <= 20) {
                            if (r > 0.8) type = 'zombie_red';
                            else if (r > 0.5) type = 'zombie_normal';
                        } else if (day >= 21) {
                            if (r > 0.9) type = 'zombie_black'; // Tank
                            else if (r > 0.8) type = 'zombie_explosive';
                            else if (r > 0.5) type = 'zombie_red';
                            else type = 'zombie_normal';
                        }

                        spawnHorde(1, type); // Call the new spawnHorde function
                    }, 1000 - (Math.min(state.wave, 15) * 50));
                }
            } else if (!isNight && state.isHorde) {
                state.isHorde = false;
                state.hordeNotificationShown = false; // [NEW] Reset Flag
                clearInterval(state.hordeInterval);
                document.body.classList.remove("horde-active");
                showBadge("Amanhecer", "Estamos seguros... por enquanto.", "fa-sun", "green");
                state.wave++;
                document.getElementById('ui-wave').innerText = state.wave;

                // Boss Removed as per request
            }

            // Consumo de Comida e Água
            if (Math.random() > 0.99 && state.population > 0) {
                state.food -= 1;
                state.water -= 1;

                if (state.food < 0) {
                    state.food = 0;
                    updatePop(-1); // Fome mata
                    showBadge("Fome", "Alguém morreu de fome!", "fa-utensils", "red");
                }
                if (state.water < 0) {
                    state.water = 0;
                    updatePop(-1); // Sede mata
                    showBadge("Sede", "Alguém morreu de sede!", "fa-tint", "cyan");
                }

                document.getElementById('ui-food').innerText = state.food;
                document.getElementById('ui-water').innerText = state.water;
            }

            // Building Effects (Factory, Hospital, Mines, Economy)
            const now = Date.now();
            // Loop grid occasionally (or every frame if optimized, let's do every frame but check timer)
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    const cell = state.grid[x][z];
                    if (!cell.type || !cell.data) continue;

                    // [NEW] Production Logic
                    if (cell.data.prodRate && cell.data.prodType) {
                        if (!cell.data.lastProd) cell.data.lastProd = now;
                        if (now - cell.data.lastProd > cell.data.prodRate) {
                            cell.data.lastProd = now;

                            // Produce
                            if (cell.data.prodType === 'money') {
                                updateMoney(cell.data.prodAmount);
                                // Feedback
                                showFloatingText(`+$${cell.data.prodAmount}`, cell.mesh.position, 'yellow');
                            } else if (cell.data.prodType === 'food') {
                                updateFood(cell.data.prodAmount);
                                showFloatingText(`+${cell.data.prodAmount} Food`, cell.mesh.position, 'orange');
                            } else if (cell.data.prodType === 'water') {
                                updateWater(cell.data.prodAmount);
                                showFloatingText(`+${cell.data.prodAmount} Water`, cell.mesh.position, 'cyan');
                            }
                        }
                    }

                    // Hospital Heal
                    if (cell.type === 'hospital') {
                        state.entities.forEach(e => {
                            if (['citizen', 'soldier', 'rick', 'michonne', 'daryl', 'carol'].includes(e.type) && e.hp < e.maxHp && e.mesh.position.distanceTo(cell.mesh.position) < 10) {
                                e.hp += 1;
                            }
                        });
                    }
                    // Mine Logic (Check zombies)
                    if (cell.type === 'mine') {
                        state.entities.forEach(e => {
                            if (e.type === 'zombie' && e.mesh.position.distanceTo(cell.mesh.position) < 2) {
                                // Explode
                                createParticles(cell.mesh.position, 0xff0000, 20);
                                SoundManager.play('explosion');
                                e.hp -= 100;
                                // AOE
                                state.entities.forEach(other => {
                                    if (other.mesh.position.distanceTo(cell.mesh.position) < 5) other.hp -= 50;
                                });
                                // Remove Mine
                                buildGroup.remove(cell.data.mesh);
                                cell.type = null; cell.data = null;
                            }
                        });
                    }
                }
            }

            // [NEW] Update Loot
            LootSystem.update();

            // Visuais Dia/Noite
            const sunAngle = (t - 0.25) * Math.PI * 2;
            sunLight.position.x = Math.cos(sunAngle) * 100;
            sunLight.position.y = Math.sin(sunAngle) * 100;

            let bg = 0x87CEEB;
            if (isNight) bg = 0x111827;
            else if (t > 0.7) bg = 0xf97316; // Pôr do sol
            scene.background.setHex(bg);
            scene.fog.color.setHex(bg);

            state.lights.forEach(l => l.visible = isNight);

            // UI Relógio
            const h = Math.floor(t * 24);
            const m = Math.floor((t * 24 * 60) % 60);
            document.getElementById('ui-time').innerText = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

            // Particles Update
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.m.position.add(p.vel);
                p.life -= 0.02;
                p.m.scale.setScalar(p.life);
                if (p.life <= 0) { fxGroup.remove(p.m); state.particles.splice(i, 1); }
            }

            // [NEW] Single Source of Truth for Population
            const survivors = state.entities.filter(e => ['citizen', 'soldier', 'rick', 'michonne', 'daryl', 'carol', 'fisherman', 'sniper', 'tank', 'marine'].includes(e.type));
            state.population = survivors.length;
            document.getElementById('ui-pop').innerText = state.population;

            // [NEW] Game Over
            if (state.gameStarted && state.population <= 0) {
                alert("GAME OVER - A Colônia Caiu");
                location.reload();
                return;
            }

            updateEntities();
        }



        // --- FLOATING TEXT SYSTEM ---
        function spawnDamageText(x, y, z, damage, isCrit = false) {
            const div = document.createElement('div');
            div.className = 'absolute pointer-events-none font-bold select-none text-shadow';
            div.style.color = isCrit ? '#ef4444' : '#fbbf24'; // Red for Crit, Amber for Normal
            div.style.fontSize = isCrit ? '24px' : '16px';
            div.style.textShadow = '1px 1px 0 #000';
            div.innerText = Math.round(damage);
            document.body.appendChild(div);

            state.floatingTexts.push({
                div: div,
                pos: new THREE.Vector3(x, y + 2, z),
                life: 1.0,
                velocity: new THREE.Vector3(0, 2, 0) // Float up
            });
        }

        function updateFloatingTexts(dt) {
            for (let i = state.floatingTexts.length - 1; i >= 0; i--) {
                const ft = state.floatingTexts[i];
                ft.life -= dt;
                ft.pos.add(ft.velocity.clone().multiplyScalar(dt));

                if (ft.life <= 0) {
                    ft.div.remove();
                    state.floatingTexts.splice(i, 1);
                } else {
                    // Project to Screen
                    const screenPos = ft.pos.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (-(screenPos.y * .5) + .5) * window.innerHeight;

                    ft.div.style.left = `${x}px`;
                    ft.div.style.top = `${y}px`;
                    ft.div.style.opacity = ft.life;
                }
            }
        }

        // --- UI HELPERS ---
        function updateMoney(v) { state.money += v; document.getElementById('ui-money').innerText = state.money; }
        function updatePop(v) {
            // state.population is now read-only from entities length
            // This function is kept if we want to show badges or effects, but logic is auto-synced
        }
        function updateFood(v) { state.food += v; document.getElementById('ui-food').innerText = state.food; }
        function updateWater(v) { state.water += v; document.getElementById('ui-water').innerText = state.water; }

        function showBadge(t, msg, i, c = 'blue') {
            const b = document.createElement('div');
            b.className = `glass p-3 rounded-l-xl border-r-4 border-${c}-500 badge-pop flex items-center gap-3 mb-2 ml-auto bg-${c}-900/50`;
            b.innerHTML = `<i class="fas ${i} text-${c}-400 text-xl"></i><div><div class="font-bold text-sm">${t}</div><div class="text-xs text-gray-300">${msg}</div></div>`;
            document.getElementById('badge-container').appendChild(b);
            setTimeout(() => b.remove(), 4000);
        }

        function renderMenu() {
            const c = document.getElementById('build-container');
            c.innerHTML = '';
            Object.entries(BUILDINGS).forEach(([k, v]) => {
                if (v.cat !== state.category && v.cat !== 'tools') return;
                const d = document.createElement('div');
                d.className = `build-card glass rounded-xl p-2 min-w-[80px] flex flex-col items-center gap-1 ${state.tool === k ? 'active' : ''}`;
                d.onclick = () => {
                    if (k === 'cursor') {
                        state.tool = null;
                    } else {
                        state.tool = k;
                    }
                    renderMenu();
                };
                d.innerHTML = `<div class="w-8 h-8 rounded-full bg-${v.color} flex items-center justify-center text-white shadow-md"><i class="fas ${v.icon}"></i></div><div class="text-[10px] font-bold uppercase mt-1 text-center">${v.name}</div><div class="text-[9px] text-yellow-400">$${v.cost}</div>`;
                c.appendChild(d);
            });
        }

        window.setCategory = (c) => {
            state.category = c;
            document.querySelectorAll('[id^="tab-"]').forEach(b => b.classList.replace('bg-green-600', 'text-gray-400')); // Reset simples
            document.getElementById(`tab-${c}`).classList.remove('text-gray-400');
            document.getElementById(`tab-${c}`).classList.add('bg-green-600', 'text-white');
            renderMenu();
        };

        // --- INPUT ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const highlight = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE), new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true }));
        scene.add(highlight);

        window.addEventListener('pointermove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(worldGroup.children);
            if (hits.length > 0) {
                highlight.position.copy(hits[0].object.position);
                highlight.position.y = 0.5;
                highlight.visible = true;
            } else highlight.visible = false;
        });

        window.addEventListener('contextmenu', e => e.preventDefault()); // Disable context menu

        window.addEventListener('pointerdown', e => {
            if (e.target.closest('.glass') || e.target.closest('button')) return;

            // Right Click = Cancel / Clear Selection
            if (e.button === 2) {
                state.tool = null;
                renderMenu();
                highlight.visible = false;
                return;
            }

            // Left Click Only
            if (e.button !== 0) return;

            // 1. Correção das Coordenadas do Mouse
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            console.log(`Clique detectado em X:${mouse.x.toFixed(2)}, Y:${mouse.y.toFixed(2)}`);

            raycaster.setFromCamera(mouse, camera);

            // 2. Lógica de Colisão (Loot)
            // Verificar interseção com caixas de loot
            // Precisamos checar os meshes dentro dos grupos de loot
            const lootMeshes = LootSystem.items.map(i => i.mesh);
            const lootHits = raycaster.intersectObjects(lootMeshes, true);

            if (lootHits.length > 0) {
                // Encontrar o item correspondente
                // O hit pode ser no box ou no icone, então pegamos o grupo pai (ou avô)
                const hitObj = lootHits[0].object;
                const lootGroup = hitObj.parent; // O grupo contém box e icon

                const index = LootSystem.items.findIndex(i => i.mesh === lootGroup);

                if (index !== -1) {
                    const item = LootSystem.items[index];

                    // 3. Feedback Visual e Remoção
                    console.log('Caixa coletada!', item.type);

                    // Efeito
                    createParticles(item.mesh.position, 0xffff00, 10);
                    SoundManager.play('collect');

                    // Atualizar saldo
                    if (item.type === 'money') updateMoney(item.val);
                    if (item.type === 'food') updateFood(item.val);

                    // Remover
                    fxGroup.remove(item.mesh);
                    LootSystem.items.splice(index, 1);
                    return; // Stop propagation
                }
            }

            // Check for Bomb Detonation
            const hits = raycaster.intersectObjects(buildGroup.children, true); // Recursive
            if (hits.length > 0) {
                const obj = hits[0].object;
                // Find parent group if mesh
                const group = obj.parent;
                // Find grid cell
                const gx = Math.round((group.position.x + (GRID_SIZE * TILE_SIZE) / 2 - TILE_SIZE / 2) / TILE_SIZE);
                const gz = Math.round((group.position.z + (GRID_SIZE * TILE_SIZE) / 2 - TILE_SIZE / 2) / TILE_SIZE);

                if (state.grid[gx] && state.grid[gx][gz] && state.grid[gx][gz].type === 'bomb') {
                    const cell = state.grid[gx][gz];
                    createParticles(cell.mesh.position, 0xff0000, 30);
                    SoundManager.play('explosion');
                    // AOE
                    state.entities.forEach(other => {
                        if (other.mesh.position.distanceTo(cell.mesh.position) < 10) other.hp -= 300;
                    });
                    buildGroup.remove(cell.data.mesh);
                    cell.type = null; cell.data = null;
                    return; // Handled
                }
            }

            if (highlight.visible && state.tool) {
                const p = highlight.position;
                const gx = Math.round((p.x + (GRID_SIZE * TILE_SIZE) / 2 - TILE_SIZE / 2) / TILE_SIZE);
                const gz = Math.round((p.z + (GRID_SIZE * TILE_SIZE) / 2 - TILE_SIZE / 2) / TILE_SIZE);
                build(gx, gz, state.tool);
            }
        });

        window.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                state.tool = null;
                renderMenu();
                highlight.visible = false;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            initGrid();
            revealMap(Math.floor(GRID_SIZE / 2), Math.floor(GRID_SIZE / 2), VISIBLE_RADIUS);
            setCategory('survival');

            // Construção inicial
            const cx = Math.floor(GRID_SIZE / 2);
            build(cx, cx, 'house');
            build(cx + 2, cx, 'farm');
            build(cx + 2, cx, 'farm');
            state.money = 5000; updateMoney(0);

            // [NEW] Initial Population
            for (let i = 0; i < 15; i++) {
                spawnEntity('citizen', (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
            }
            for (let i = 0; i < 5; i++) {
                spawnEntity('zombie', (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
            }

            // [NEW] Initial Loot
            LootSystem.spawnRandom(10);

            state.gameStarted = true; // [NEW] Start Game Over Check
        }
        window.startGame = startGame;

        function animate() {
            const dt = clock.getDelta();
            controls.update();
            updateLogic();
            updateEntities();
            updateFloatingTexts(dt); // [NEW] Update Floating Texts
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

    </script>
</body>

</html>
```