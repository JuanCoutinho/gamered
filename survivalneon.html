<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SURVIVOR: 3D PROTOCOL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --bg: #050505;
            --cyan: #00f3ff;
            --magenta: #ff00ff;
            --yellow: #ffea00;
            --white: #fff;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            font-family: 'Orbitron', sans-serif;
            color: var(--white);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* UI OVERLAY */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .bar-box {
            width: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
            transform: skewX(-15deg);
            padding: 3px;
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 10px;
            width: 100%;
            transition: width 0.1s;
        }

        .hp-fill {
            background: var(--cyan);
            box-shadow: 0 0 10px var(--cyan);
        }

        .xp-fill {
            background: var(--yellow);
            box-shadow: 0 0 10px var(--yellow);
        }

        .score-display {
            text-align: right;
        }

        .score-val {
            font-size: 32px;
            font-weight: 900;
            color: var(--magenta);
            text-shadow: 0 0 10px var(--magenta);
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 99;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            background: linear-gradient(90deg, var(--cyan), var(--magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            font-family: inherit;
            font-weight: bold;
            color: var(--bg);
            background: var(--cyan);
            border: none;
            transform: skewX(-15deg);
            cursor: pointer;
            box-shadow: 0 0 20px var(--cyan);
            transition: 0.2s;
        }

        .btn:hover {
            background: var(--white);
            transform: skewX(-15deg) scale(1.1);
            box-shadow: 0 0 40px var(--white);
        }

        /* CARDS */
        #card-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .card {
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: 0.2s;
        }

        .card:hover {
            border-color: var(--yellow);
            transform: translateY(-10px);
            box-shadow: 0 0 20px var(--yellow);
        }

        .card h3 {
            color: var(--cyan);
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .card p {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        /* MOBILE CONTROLS */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
        }

        .stick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }

            h1 {
                font-size: 32px;
            }
        }
    </style>
    <!-- THREE.JS MODULES -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <audio id="bgm" loop>
        <source src="https://cdn.pixabay.com/audio/2022/03/15/audio_c8c8a73467.mp3" type="audio/mpeg">
    </audio>

    <div id="canvas-container"></div>

    <div id="ui">
        <div class="hud-top">
            <div>
                <div style="font-size:10px; color:var(--cyan);">SHIELD</div>
                <div class="bar-box">
                    <div class="bar-fill hp-fill" id="hp-bar"></div>
                </div>
                <div style="font-size:10px; color:var(--yellow); margin-top:5px;">SYNC</div>
                <div class="bar-box" style="width:150px;">
                    <div class="bar-fill xp-fill" id="xp-bar"></div>
                </div>
            </div>
            <div class="score-display">
                <div class="score-val" id="score">0</div>
                <div style="font-size:14px; color:#888;">WAVE <span id="wave">1</span></div>
            </div>
        </div>
        <div id="mobile-controls">
            <div class="stick-zone" id="stick"></div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NEON SURVIVOR<br><span style="font-size:24px; color:#fff;">3D PROTOCOL</span></h1>
        <button class="btn" id="start-btn">INITIATE</button>
        <p style="color:#666; margin-top:20px; font-size:12px;">WASD to Move | Auto-Fire</p>
    </div>

    <div id="levelup-screen" class="screen hidden">
        <h1>SYSTEM UPGRADE</h1>
        <div id="card-container"></div>
    </div>

    <div id="gameover-screen" class="screen hidden">
        <h1 style="color:var(--magenta);">CRITICAL FAILURE</h1>
        <p style="font-size:24px; margin-bottom:30px;">SCORE: <span id="final-score">0</span></p>
        <button class="btn" onclick="location.reload()">REBOOT</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        const C = {
            COLORS: { cyan: 0x00f3ff, magenta: 0xff00ff, yellow: 0xffea00, green: 0x00ff00, red: 0xff0000, white: 0xffffff },
            MAX_ENEMIES: 50,
            WAVE_INTERVAL: 30,
            TIERS: [
                { hp: 15, speed: 2.2, color: 0x00ff00, scale: 1.0, score: 10, geo: 'tetra' },
                { hp: 40, speed: 2.8, color: 0xffea00, scale: 1.2, score: 30, geo: 'box' },
                { hp: 120, speed: 1.5, color: 0xff0000, scale: 1.5, score: 100, geo: 'ico' }
            ]
        };

        // --- AUDIO SYSTEM ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.4;
                this.master.connect(this.ctx.destination);
                this.bgm = document.getElementById('bgm');
                this.bgm.volume = 0.3;
            }
            startMusic() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                this.bgm.play().catch(e => console.log("BGM blocked", e));
            }
            playTone(freq, type, dur, vol = 0.5) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.master);
                osc.start(); osc.stop(this.ctx.currentTime + dur);
            }
            shoot() { this.playTone(400, 'square', 0.1, 0.1); }
            hit() { this.playTone(150, 'sawtooth', 0.1, 0.2); }
            levelup() {
                this.playTone(440, 'sine', 0.3, 0.3);
                setTimeout(() => this.playTone(880, 'sine', 0.4, 0.3), 150);
            }
            explode() {
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource();
                src.buffer = buf;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                src.connect(gain); gain.connect(this.master);
                src.start();
            }
        }

        // --- 3D ENGINE ---
        class Engine3D {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.002);

                // Camera
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
                this.camera.position.set(0, 120, 100);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                // Post Processing (Bloom)
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 2.0; // High bloom for neon
                bloomPass.radius = 0.5;
                this.composer.addPass(bloomPass);

                // Environment
                const grid = new THREE.GridHelper(2000, 100, 0x222222, 0x111111);
                this.scene.add(grid);

                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(100, 200, 100);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0x404040));

                // Geometries & Materials (Shared)
                this.geos = {
                    box: new THREE.BoxGeometry(1, 1, 1),
                    sphere: new THREE.SphereGeometry(1, 8, 8),
                    tetra: new THREE.TetrahedronGeometry(1),
                    ico: new THREE.IcosahedronGeometry(1),
                    plane: new THREE.PlaneGeometry(1, 1)
                };
                this.mats = {
                    cyan: new THREE.MeshStandardMaterial({ color: C.COLORS.cyan, emissive: C.COLORS.cyan, emissiveIntensity: 2 }),
                    magenta: new THREE.MeshStandardMaterial({ color: C.COLORS.magenta, emissive: C.COLORS.magenta, emissiveIntensity: 2 }),
                    yellow: new THREE.MeshStandardMaterial({ color: C.COLORS.yellow, emissive: C.COLORS.yellow, emissiveIntensity: 2 }),
                    green: new THREE.MeshStandardMaterial({ color: C.COLORS.green, emissive: C.COLORS.green, emissiveIntensity: 2 }),
                    red: new THREE.MeshStandardMaterial({ color: C.COLORS.red, emissive: C.COLORS.red, emissiveIntensity: 2 }),
                    white: new THREE.MeshStandardMaterial({ color: C.COLORS.white, emissive: C.COLORS.white, emissiveIntensity: 1 })
                };

                window.addEventListener('resize', () => this.resize());
            }
            resize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
            render() {
                this.composer.render();
            }
        }

        // --- ENTITIES ---
        class Entity {
            constructor(game) {
                this.game = game;
                this.mesh = null;
                this.alive = false;
                this.x = 0; this.z = 0;
            }
            initMesh(geo, mat, scale) {
                if (!this.mesh) {
                    this.mesh = new THREE.Mesh(geo, mat);
                    this.game.engine.scene.add(this.mesh);
                } else {
                    this.mesh.geometry = geo;
                    this.mesh.material = mat;
                    this.mesh.visible = true;
                }
                this.mesh.scale.set(scale, scale, scale);
            }
            kill() {
                this.alive = false;
                if (this.mesh) this.mesh.visible = false;
            }
            updateMeshPosition() {
                if (this.mesh) {
                    this.mesh.position.set(this.x, 2, this.z); // y=2 to sit on grid
                }
            }
        }

        class Player extends Entity {
            constructor(game) {
                super(game);
                this.initMesh(game.engine.geos.box, game.engine.mats.cyan, 4);
                this.reset();
            }
            reset() {
                this.x = 0; this.z = 0;
                this.hp = 100; this.maxHp = 100;
                this.speed = 1.5;
                this.atkSpeed = 30; this.atkTimer = 0;
                this.projCount = 1;
                this.aura = false; this.auraRadius = 30;
                this.alive = true;
                this.mesh.visible = true;
            }
            update(dt) {
                const k = this.game.input.keys;
                this.x += k.x * this.speed * dt * 60;
                this.z += k.y * this.speed * dt * 60;

                // Camera Follow
                this.game.engine.camera.position.x += (this.x - this.game.engine.camera.position.x) * 0.1;
                this.game.engine.camera.position.z += ((this.z + 100) - this.game.engine.camera.position.z) * 0.1;
                this.game.engine.camera.lookAt(this.x, 0, this.z);

                this.updateMeshPosition();
                this.mesh.rotation.y += 0.05;
                this.mesh.rotation.x += 0.02;

                // Attack
                this.atkTimer -= dt * 60;
                if (this.atkTimer <= 0) {
                    const target = this.game.getNearestEnemy();
                    if (target) {
                        this.atkTimer = this.atkSpeed;
                        this.game.audio.shoot();
                        for (let i = 0; i < this.projCount; i++) {
                            const angle = Math.atan2(target.z - this.z, target.x - this.x) + (i - this.projCount / 2) * 0.2;
                            const b = this.game.bullets.get();
                            b.spawn(this.x, this.z, Math.cos(angle) * 3, Math.sin(angle) * 3);
                        }
                    }
                }

                // Aura
                if (this.aura) {
                    this.game.enemies.active.forEach(e => {
                        if (Math.hypot(e.x - this.x, e.z - this.z) < this.auraRadius) e.hit(0.5);
                    });
                }

                // Regen
                if (this.hp < this.maxHp) this.hp += 0.02 * dt * 60;
                document.getElementById('hp-bar').style.width = (this.hp / this.maxHp) * 100 + '%';
            }
        }

        class Enemy extends Entity {
            constructor(game) { super(game); }
            spawn(tier) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 150 + Math.random() * 50; // Spawn radius
                this.x = this.game.player.x + Math.cos(angle) * dist;
                this.z = this.game.player.z + Math.sin(angle) * dist;

                this.tier = tier;
                this.hp = tier.hp;
                this.speed = tier.speed;

                let mat = this.game.engine.mats.green;
                if (tier.color === C.COLORS.yellow) mat = this.game.engine.mats.yellow;
                if (tier.color === C.COLORS.red) mat = this.game.engine.mats.red;

                this.initMesh(this.game.engine.geos[tier.geo], mat, 3 * tier.scale);
                this.alive = true;
            }
            update(dt) {
                if (!this.alive) return;
                const dx = this.game.player.x - this.x;
                const dz = this.game.player.z - this.z;
                const dist = Math.hypot(dx, dz);

                this.x += (dx / dist) * this.speed * dt * 60 * 0.3; // Slower in 3D scale
                this.z += (dz / dist) * this.speed * dt * 60 * 0.3;

                this.updateMeshPosition();
                this.mesh.rotation.y += 0.1;

                if (dist < 5) {
                    this.game.player.hp -= 0.5;
                    if (this.game.player.hp <= 0) this.game.gameOver();
                }
            }
            hit(dmg) {
                this.hp -= dmg;
                if (this.hp <= 0) this.die();
            }
            die() {
                this.kill();
                this.game.score += this.tier.score;
                this.game.xp += 10;
                this.game.audio.hit();
                this.game.enemies.release(this);

                const xp = this.game.orbs.get();
                xp.spawn(this.x, this.z);

                for (let i = 0; i < 4; i++) {
                    const p = this.game.particles.get();
                    p.spawn(this.x, this.z, this.mesh.material);
                }

                document.getElementById('score').innerText = this.game.score;
                this.game.checkLevelUp();
            }
        }

        class Bullet extends Entity {
            constructor(game) { super(game); }
            spawn(x, z, vx, vz) {
                this.x = x; this.z = z;
                this.vx = vx; this.vz = vz;
                this.life = 60;
                this.initMesh(this.game.engine.geos.sphere, this.game.engine.mats.yellow, 1);
                this.alive = true;
            }
            update(dt) {
                this.x += this.vx * dt * 60;
                this.z += this.vz * dt * 60;
                this.life -= dt * 60;
                this.updateMeshPosition();

                if (this.life <= 0) { this.game.bullets.release(this); this.kill(); return; }

                const enemies = this.game.enemies.active;
                for (let i = 0; i < enemies.length; i++) {
                    const e = enemies[i];
                    if (Math.hypot(e.x - this.x, e.z - this.z) < 4) {
                        e.hit(10);
                        this.game.bullets.release(this);
                        this.kill();
                        return;
                    }
                }
            }
        }

        class Particle extends Entity {
            constructor(game) { super(game); }
            spawn(x, z, mat) {
                this.x = x; this.z = z;
                this.vx = (Math.random() - 0.5) * 2; this.vz = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.initMesh(this.game.engine.geos.box, mat, 1);
                this.alive = true;
            }
            update(dt) {
                this.x += this.vx * dt * 60;
                this.z += this.vz * dt * 60;
                this.life -= 0.05 * dt * 60;
                this.updateMeshPosition();
                this.mesh.scale.setScalar(this.life);
                if (this.life <= 0) { this.game.particles.release(this); this.kill(); }
            }
        }

        class XpOrb extends Entity {
            constructor(game) { super(game); }
            spawn(x, z) {
                this.x = x; this.z = z;
                this.initMesh(this.game.engine.geos.sphere, this.game.engine.mats.cyan, 1.5);
                this.alive = true;
            }
            update(dt) {
                const dist = Math.hypot(this.game.player.x - this.x, this.game.player.z - this.z);
                if (dist < 30) {
                    this.x += (this.game.player.x - this.x) * 0.1 * dt * 60;
                    this.z += (this.game.player.z - this.z) * 0.1 * dt * 60;
                }
                this.updateMeshPosition();
                if (dist < 3) {
                    this.game.xp += 10;
                    this.game.orbs.release(this);
                    this.kill();
                    this.game.checkLevelUp();
                }
            }
        }

        // --- POOL & INPUT ---
        class Pool {
            constructor(createFn) {
                this.create = createFn;
                this.pool = [];
                this.active = [];
            }
            get() {
                const item = this.pool.length > 0 ? this.pool.pop() : this.create();
                this.active.push(item);
                return item;
            }
            release(item) {
                const idx = this.active.indexOf(item);
                if (idx > -1) {
                    this.active.splice(idx, 1);
                    this.pool.push(item);
                }
            }
            update(dt) { for (let i = this.active.length - 1; i >= 0; i--) this.active[i].update(dt); }
            clear() {
                this.active.forEach(i => i.kill());
                this.pool = this.pool.concat(this.active);
                this.active = [];
            }
        }

        class InputHandler {
            constructor() {
                this.keys = { x: 0, y: 0 };
                window.addEventListener('keydown', e => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
                    if (e.key === 'w' || e.key === 'ArrowUp') this.keys.y = -1;
                    if (e.key === 's' || e.key === 'ArrowDown') this.keys.y = 1;
                    if (e.key === 'a' || e.key === 'ArrowLeft') this.keys.x = -1;
                    if (e.key === 'd' || e.key === 'ArrowRight') this.keys.x = 1;
                });
                window.addEventListener('keyup', e => {
                    if (e.key === 'w' || e.key === 'ArrowUp' || e.key === 's' || e.key === 'ArrowDown') this.keys.y = 0;
                    if (e.key === 'a' || e.key === 'ArrowLeft' || e.key === 'd' || e.key === 'ArrowRight') this.keys.x = 0;
                });
                const stick = document.getElementById('stick');
                stick.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = stick.getBoundingClientRect();
                    const dx = touch.clientX - (rect.left + rect.width / 2);
                    const dy = touch.clientY - (rect.top + rect.height / 2);
                    const angle = Math.atan2(dy, dx);
                    this.keys.x = Math.cos(angle);
                    this.keys.y = Math.sin(angle);
                });
                stick.addEventListener('touchend', () => { this.keys.x = 0; this.keys.y = 0; });
            }
        }

        // --- GAME ---
        class Game {
            constructor() {
                this.engine = new Engine3D();
                this.input = new InputHandler();
                this.audio = new SoundManager();

                this.enemies = new Pool(() => new Enemy(this));
                this.bullets = new Pool(() => new Bullet(this));
                this.particles = new Pool(() => new Particle(this));
                this.orbs = new Pool(() => new XpOrb(this));

                this.player = new Player(this);
                this.state = 'MENU';
                this.lastTime = 0;
                this.xp = 0; this.xpNext = 100; this.score = 0; this.wave = 1; this.waveTimer = 0;

                document.getElementById('start-btn').onclick = () => this.init();
            }

            init() {
                this.state = 'PLAYING';
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                this.audio.startMusic();

                this.enemies.clear(); this.bullets.clear(); this.particles.clear(); this.orbs.clear();
                this.player.reset();
                this.score = 0; this.xp = 0; this.xpNext = 100;
                this.wave = 1; this.waveTimer = 0;

                this.lastTime = performance.now();
                requestAnimationFrame(t => this.loop(t));
            }

            getNearestEnemy() {
                let t = null, d = Infinity;
                this.enemies.active.forEach(e => {
                    const dist = Math.hypot(e.x - this.player.x, e.z - this.player.z);
                    if (dist < d) { d = dist; t = e; }
                });
                return t;
            }

            checkLevelUp() {
                document.getElementById('xp-bar').style.width = (this.xp / this.xpNext) * 100 + '%';
                if (this.xp >= this.xpNext) {
                    this.xp = 0; this.xpNext *= 1.5;
                    this.state = 'PAUSED';
                    this.audio.levelup();
                    this.showCards();
                }
            }

            showCards() {
                const screen = document.getElementById('levelup-screen');
                const container = document.getElementById('card-container');
                container.innerHTML = '';
                screen.classList.remove('hidden');

                const opts = [
                    { name: 'MULTISHOT', desc: '+1 Projectile', fn: () => this.player.projCount++ },
                    { name: 'STATIC AURA', desc: 'Damage Aura', fn: () => { this.player.aura = true; this.player.auraRadius += 10; } },
                    { name: 'OVERCLOCK', desc: '+20% Atk Speed', fn: () => this.player.atkSpeed *= 0.8 },
                    {
                        name: 'NOVA BLAST', desc: 'Clear Screen', fn: () => {
                            this.audio.explode();
                            this.enemies.active.forEach(e => e.die());
                        }
                    }
                ];

                for (let i = 0; i < 3; i++) {
                    const opt = opts[Math.floor(Math.random() * opts.length)];
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `<h3>${opt.name}</h3><p>${opt.desc}</p>`;
                    card.onclick = () => {
                        opt.fn();
                        screen.classList.add('hidden');
                        this.state = 'PLAYING';
                        this.lastTime = performance.now();
                        requestAnimationFrame(t => this.loop(t));
                    };
                    container.appendChild(card);
                }
            }

            gameOver() {
                this.state = 'GAMEOVER';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = this.score;
            }

            loop(now) {
                if (this.state !== 'PLAYING') {
                    this.engine.render(); // Keep rendering even if paused/menu
                    if (this.state === 'PLAYING') requestAnimationFrame(t => this.loop(t)); // Double check
                    else requestAnimationFrame(t => this.loop(t)); // Loop for rendering
                    return;
                }

                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;

                // Wave
                this.waveTimer += dt;
                if (this.waveTimer > C.WAVE_INTERVAL) {
                    this.waveTimer = 0;
                    this.wave++;
                    document.getElementById('wave').innerText = this.wave;
                }

                // Spawn
                if (this.enemies.active.length < C.MAX_ENEMIES) {
                    if (Math.random() < 0.05 + (this.wave * 0.01)) {
                        let tier = C.TIERS[0];
                        if (this.wave > 2 && Math.random() > 0.7) tier = C.TIERS[1];
                        if (this.wave > 5 && Math.random() > 0.8) tier = C.TIERS[2];
                        this.enemies.get().spawn(tier);
                    }
                }

                this.player.update(dt);
                this.enemies.update(dt);
                this.bullets.update(dt);
                this.particles.update(dt);
                this.orbs.update(dt);

                this.engine.render();
                requestAnimationFrame(t => this.loop(t));
            }
        }

        const game = new Game();
    </script>
</body>

</html>