<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIRATE.IO: TROPICAL SEAS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pirata+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Pirata One', cursive;
            user-select: none;
        }

        /* UI OVERLAY */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* MINIMAP */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(255, 248, 220, 0.8);
            border: 6px solid #8B4513;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        /* STATS */
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 3px 3px 0 #8B4513;
        }

        #score {
            font-size: 56px;
            margin-bottom: -10px;
        }

        #level {
            font-size: 36px;
            color: #fff;
        }

        /* HEALTH BARS */
        .hp-bar {
            position: absolute;
            width: 70px;
            height: 10px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 5px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            transition: width 0.2s;
        }

        /* START SCREEN */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB, #006994);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }

        h1 {
            font-size: 120px;
            color: #FFD700;
            margin: 0;
            text-shadow: 5px 5px 0 #8B4513;
            letter-spacing: 5px;
        }

        p {
            color: #fff;
            font-size: 28px;
            margin-bottom: 50px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
        }

        .btn {
            padding: 20px 60px;
            font-size: 40px;
            font-family: inherit;
            background: #8B4513;
            color: #FFD700;
            border: 4px solid #FFD700;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .btn:hover {
            transform: scale(1.1) rotate(-2deg);
            background: #A0522D;
        }

        /* CONTROLS HINT */
        #controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            text-shadow: 2px 2px 0 #000;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 30px;
            border-radius: 20px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui">
        <div id="stats">
            <div id="score">GOLD: 0</div>
            <div id="level">LVL 1</div>
        </div>
        <div id="minimap-container">
            <canvas id="minimap" width="180" height="180"></canvas>
        </div>
        <div id="controls-hint">
            WASD to Sail • MOUSE to Aim • CLICK L/R to Fire Cannons
        </div>
    </div>

    <div id="start-screen">
        <h1>PIRATE.IO</h1>
        <p>CONQUER THE TROPICAL SEAS</p>
        <button class="btn" id="start-btn">SET SAIL</button>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const C = {
            MAP_SIZE: 1500,
            BOT_COUNT: 15,
            GRAVITY: 25,
            WATER_COLOR: 0x0077be,
            SHIP_SPEED: 18,
            TURN_SPEED: 1.2,
            CANNON_RANGE: 90,
            CANNON_SPEED: 50,
            WAVE_HEIGHT: 1.5,
            WAVE_FREQ: 0.05,
            WAVE_SPEED: 1.0
        };

        // --- AUDIO ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.3;
                this.master.connect(this.ctx.destination);
                this.enabled = false;
            }
            enable() { if (this.ctx.state === 'suspended') this.ctx.resume(); this.enabled = true; }

            playTone(freq, type, dur, vol = 0.5, slide = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slide) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.master);
                osc.start(); osc.stop(this.ctx.currentTime + dur);
            }

            playNoise(dur, vol = 0.5, filterFreq = null) {
                if (!this.enabled) return;
                const bufSize = this.ctx.sampleRate * dur;
                const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource();
                src.buffer = buf;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);

                let node = src;
                if (filterFreq) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = filterFreq;
                    src.connect(filter);
                    node = filter;
                }
                node.connect(gain); gain.connect(this.master);
                src.start();
            }

            cannon() { this.playNoise(0.5, 0.7, 150); this.playTone(50, 'square', 0.3, 0.6, -20); }
            impact() { this.playTone(150, 'sawtooth', 0.1, 0.5); this.playNoise(0.2, 0.4, 1000); }
            splash() { this.playNoise(0.4, 0.3, 500); }
            gold() { this.playTone(1000, 'sine', 0.1, 0.4); setTimeout(() => this.playTone(1500, 'sine', 0.2, 0.4), 80); }
            sink() { this.playNoise(1.5, 0.5, 80); this.playTone(80, 'sawtooth', 1.5, 0.5, -60); }
        }

        // --- VFX SYSTEM ---
        class ParticleManager {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];

                // Geometries
                this.wakeGeo = new THREE.PlaneGeometry(1, 1);
                this.wakeGeo.rotateX(-Math.PI / 2);
                this.smokeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                this.splashGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                this.explGeo = new THREE.DodecahedronGeometry(0.8);

                // Materials
                this.wakeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
                this.smokeMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.8 });
                this.splashMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB });
                this.explMat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
                this.woodMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            }

            spawn(pos, type, count = 1, spread = 0) {
                for (let i = 0; i < count; i++) {
                    let mesh, life, vel;
                    const p = pos.clone().add(new THREE.Vector3((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread));

                    if (type === 'WAKE') {
                        mesh = new THREE.Mesh(this.wakeGeo, this.wakeMat);
                        life = 1.5;
                        vel = new THREE.Vector3(0, 0, 0);
                        mesh.scale.setScalar(Math.random() * 1 + 0.5);
                    } else if (type === 'SMOKE') {
                        mesh = new THREE.Mesh(this.smokeGeo, this.smokeMat);
                        life = 1.0;
                        vel = new THREE.Vector3((Math.random() - 0.5) * 2, 2 + Math.random() * 2, (Math.random() - 0.5) * 2);
                        mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    } else if (type === 'SPLASH') {
                        mesh = new THREE.Mesh(this.splashGeo, this.splashMat);
                        life = 0.8;
                        vel = new THREE.Vector3((Math.random() - 0.5) * 5, 5 + Math.random() * 5, (Math.random() - 0.5) * 5);
                    } else if (type === 'EXPLOSION') {
                        mesh = new THREE.Mesh(this.explGeo, this.explMat);
                        life = 0.6;
                        vel = new THREE.Vector3((Math.random() - 0.5) * 8, 5 + Math.random() * 5, (Math.random() - 0.5) * 8);
                    } else if (type === 'WOOD') {
                        mesh = new THREE.Mesh(this.splashGeo, this.woodMat);
                        life = 1.5;
                        vel = new THREE.Vector3((Math.random() - 0.5) * 6, 6 + Math.random() * 4, (Math.random() - 0.5) * 6);
                    }

                    mesh.position.copy(p);
                    this.scene.add(mesh);
                    this.particles.push({ mesh, life, maxLife: life, vel, type });
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= dt;

                    if (p.type !== 'WAKE') {
                        p.vel.y -= C.GRAVITY * dt * 0.5; // Less gravity for particles
                        p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                        p.mesh.rotation.x += dt * 2;
                    } else {
                        p.mesh.scale.multiplyScalar(1.01);
                        p.mesh.material.opacity = (p.life / p.maxLife) * 0.6;
                    }

                    if (p.type === 'EXPLOSION') {
                        p.mesh.scale.multiplyScalar(1.05);
                    }

                    if (p.life <= 0 || (p.type !== 'WAKE' && p.mesh.position.y < 0)) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        // --- SHIP BUILDER ---
        function createShipMesh(color) {
            const group = new THREE.Group();

            // Hull
            const hullGeo = new THREE.BoxGeometry(2, 1.5, 5, 2, 1, 4);
            const pos = hullGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const z = pos.getZ(i);
                const y = pos.getY(i);
                if (z < -2) { pos.setX(i, pos.getX(i) * 0.1); } // Bow
                if (y < -0.5) { pos.setX(i, pos.getX(i) * 0.6); } // Bottom
                if (z > 2) { pos.setY(i, pos.getY(i) + 0.5); } // Stern raise
            }
            hullGeo.computeVertexNormals();
            const hullMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const hull = new THREE.Mesh(hullGeo, hullMat);
            hull.position.y = 0.5;
            group.add(hull);

            // Details (Rail)
            const rail = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.3, 5.2), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
            rail.position.y = 1.3;
            group.add(rail);

            // Masts
            const mastMat = new THREE.MeshStandardMaterial({ color: 0x3E2723 });
            const mainMast = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 7), mastMat);
            mainMast.position.set(0, 3.5, 0);
            group.add(mainMast);

            // Sails
            const sailMat = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide, roughness: 0.9 });
            const sailGeo = new THREE.PlaneGeometry(3.5, 4.5, 4, 4);
            // Curve sail
            const sailPos = sailGeo.attributes.position;
            for (let i = 0; i < sailPos.count; i++) {
                sailPos.setZ(i, Math.sin(sailPos.getX(i) * 0.8) * 0.8);
            }
            sailGeo.computeVertexNormals();
            const sail = new THREE.Mesh(sailGeo, sailMat);
            sail.position.set(0, 4.5, 0.3);
            sail.rotation.y = Math.PI / 2;
            group.add(sail);

            // Flag
            const flagGeo = new THREE.PlaneGeometry(1, 0.6);
            const flagMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(0, 7.2, -0.6);
            flag.rotation.y = Math.PI / 2;
            group.add(flag);

            // Cannons
            const cannonGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.0);
            const cannonMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2 });

            const addCannon = (x, z) => {
                const c = new THREE.Mesh(cannonGeo, cannonMat);
                c.rotation.z = Math.PI / 2;
                c.position.set(x, 1.0, z);
                group.add(c);
            };

            addCannon(1.0, 0.5); addCannon(1.0, 1.8); addCannon(1.0, -0.8);
            addCannon(-1.0, 0.5); addCannon(-1.0, 1.8); addCannon(-1.0, -0.8);

            return group;
        }

        // --- GAME ---
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
                this.camera.position.set(0, 40, 40);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // Lights
                const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0xf0e68c, 0.6);
                this.scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xfffaed, 1.0);
                dirLight.position.set(100, 200, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.top = 150; dirLight.shadow.camera.bottom = -150;
                dirLight.shadow.camera.left = -150; dirLight.shadow.camera.right = 150;
                this.scene.add(dirLight);

                // Water
                const waterGeo = new THREE.PlaneGeometry(C.MAP_SIZE, C.MAP_SIZE, 128, 128);
                waterGeo.rotateX(-Math.PI / 2);
                // Store original positions for animation
                waterGeo.userData.origPos = waterGeo.attributes.position.clone();

                const waterMat = new THREE.MeshStandardMaterial({
                    color: C.WATER_COLOR, roughness: 0.0, metalness: 0.1, flatShading: true
                });
                this.water = new THREE.Mesh(waterGeo, waterMat);
                this.water.receiveShadow = true;
                this.scene.add(this.water);

                // Environment
                this.initEnvironment();

                // Systems
                this.audio = new SoundManager();
                this.vfx = new ParticleManager(this.scene);

                // State
                this.ships = [];
                this.projectiles = [];
                this.crates = [];
                this.clock = new THREE.Clock();
                this.keys = {};
                this.mouse = new THREE.Vector2();

                // Player
                this.player = this.spawnShip(0, 0, true);

                // Bots
                for (let i = 0; i < C.BOT_COUNT; i++) {
                    const x = (Math.random() - 0.5) * C.MAP_SIZE * 0.7;
                    const z = (Math.random() - 0.5) * C.MAP_SIZE * 0.7;
                    this.spawnShip(x, z, false);
                }

                // UI
                this.minimapCtx = document.getElementById('minimap').getContext('2d');

                // Events
                document.getElementById('start-btn').onclick = () => {
                    this.audio.enable();
                    document.getElementById('start-screen').style.display = 'none';
                };
                window.addEventListener('resize', () => this.resize());
                document.addEventListener('keydown', e => this.keys[e.code] = true);
                document.addEventListener('keyup', e => this.keys[e.code] = false);
                document.addEventListener('mousemove', e => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });
                document.addEventListener('mousedown', e => {
                    if (this.player.alive) {
                        if (e.button === 0) this.fireCannons(this.player, -1);
                        if (e.button === 2) this.fireCannons(this.player, 1);
                    }
                });
                document.addEventListener('contextmenu', e => e.preventDefault());

                this.animate();
            }

            initEnvironment() {
                // Islands
                const islandGeo = new THREE.ConeGeometry(15, 10, 6);
                const islandMat = new THREE.MeshStandardMaterial({ color: 0xF4A460, roughness: 1.0 }); // Sand
                const treeTrunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 5, 5);
                const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const treeLeafGeo = new THREE.ConeGeometry(3, 4, 5);
                const treeLeafMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });

                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * C.MAP_SIZE * 0.9;
                    const z = (Math.random() - 0.5) * C.MAP_SIZE * 0.9;
                    // Avoid center
                    if (Math.abs(x) < 50 && Math.abs(z) < 50) continue;

                    const island = new THREE.Mesh(islandGeo, islandMat);
                    island.position.set(x, -2, z);
                    island.scale.set(1 + Math.random(), 1, 1 + Math.random());
                    this.scene.add(island);

                    // Trees
                    if (Math.random() > 0.3) {
                        const trunk = new THREE.Mesh(treeTrunkGeo, treeTrunkMat);
                        trunk.position.set(0, 5, 0);
                        island.add(trunk);
                        const leaf = new THREE.Mesh(treeLeafGeo, treeLeafMat);
                        leaf.position.set(0, 4, 0);
                        trunk.add(leaf);
                    }
                }

                // Clouds
                const cloudGeo = new THREE.BoxGeometry(1, 1, 1);
                const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                for (let i = 0; i < 30; i++) {
                    const cloud = new THREE.Group();
                    const chunks = 3 + Math.floor(Math.random() * 5);
                    for (let j = 0; j < chunks; j++) {
                        const mesh = new THREE.Mesh(cloudGeo, cloudMat);
                        mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 5);
                        mesh.scale.setScalar(2 + Math.random() * 3);
                        cloud.add(mesh);
                    }
                    cloud.position.set((Math.random() - 0.5) * C.MAP_SIZE, 40 + Math.random() * 20, (Math.random() - 0.5) * C.MAP_SIZE);
                    this.scene.add(cloud);
                }
            }

            spawnShip(x, z, isPlayer) {
                const color = isPlayer ? 0xffffff : new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                const mesh = createShipMesh(color);
                mesh.position.set(x, 0, z);
                mesh.castShadow = true;
                this.scene.add(mesh);

                const div = document.createElement('div');
                div.className = 'hp-bar';
                div.innerHTML = '<div class="hp-fill"></div>';
                document.body.appendChild(div);

                const ship = {
                    mesh: mesh,
                    isPlayer: isPlayer,
                    hp: 100,
                    maxHp: 100,
                    level: 1,
                    score: 0,
                    velocity: new THREE.Vector3(),
                    speed: 0,
                    rotationSpeed: 0,
                    alive: true,
                    lastFire: 0,
                    hpBar: div,
                    aiState: 'WANDER',
                    aiTimer: 0
                };
                this.ships.push(ship);
                return ship;
            }

            getWaveHeight(x, z, time) {
                return Math.sin(x * C.WAVE_FREQ + time * C.WAVE_SPEED) * C.WAVE_HEIGHT +
                    Math.cos(z * C.WAVE_FREQ * 0.8 + time * C.WAVE_SPEED * 0.8) * C.WAVE_HEIGHT * 0.5;
            }

            getWaveNormal(x, z, time) {
                // Approximate normal by sampling neighbors
                const h = this.getWaveHeight(x, z, time);
                const hx = this.getWaveHeight(x + 1, z, time);
                const hz = this.getWaveHeight(x, z + 1, time);
                const v1 = new THREE.Vector3(1, hx - h, 0);
                const v2 = new THREE.Vector3(0, hz - h, 1);
                return new THREE.Vector3().crossVectors(v2, v1).normalize();
            }

            updateWater(time) {
                const pos = this.water.geometry.attributes.position;
                const orig = this.water.geometry.userData.origPos;

                for (let i = 0; i < pos.count; i++) {
                    const x = orig.getX(i);
                    const z = orig.getY(i); // Plane rotated
                    const y = this.getWaveHeight(x, z, time);
                    pos.setZ(i, y);
                }
                this.water.geometry.attributes.position.needsUpdate = true;
                this.water.geometry.computeVertexNormals();
            }

            fireCannons(ship, side) {
                const now = this.clock.getElapsedTime();
                if (now - ship.lastFire < 0.6) return;
                ship.lastFire = now;

                this.audio.cannon();

                for (let i = -1; i <= 1; i++) {
                    const offset = new THREE.Vector3(side * 1.5, 1.5, i * 1.5);
                    offset.applyQuaternion(ship.mesh.quaternion);
                    const pos = ship.mesh.position.clone().add(offset);

                    const dir = new THREE.Vector3(side, 0.1, 0);
                    dir.applyQuaternion(ship.mesh.quaternion);
                    dir.normalize();

                    const vel = dir.multiplyScalar(C.CANNON_SPEED).add(ship.velocity);

                    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({ color: 0x111111 }));
                    ball.position.copy(pos);
                    this.scene.add(ball);

                    this.projectiles.push({ mesh: ball, velocity: vel, owner: ship, life: 2.5 });

                    // Smoke VFX
                    this.vfx.spawn(pos, 'SMOKE', 2, 0.5);
                }
            }

            spawnCrate(pos, value) {
                const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                const mat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.5, roughness: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                this.scene.add(mesh);
                this.crates.push({ mesh: mesh, value: value, active: true });
            }

            updateShips(dt, time) {
                this.ships.forEach(ship => {
                    if (!ship.alive) return;

                    // Input / AI
                    let throttle = 0;
                    let turn = 0;

                    if (ship.isPlayer) {
                        if (this.keys['KeyW']) throttle = 1;
                        if (this.keys['KeyS']) throttle = -0.5;
                        if (this.keys['KeyA']) turn = 1;
                        if (this.keys['KeyD']) turn = -1;
                    } else {
                        ship.aiTimer -= dt;
                        if (ship.aiTimer <= 0) {
                            ship.aiTimer = 1 + Math.random() * 3;
                            const dist = ship.mesh.position.distanceTo(this.player.mesh.position);
                            ship.aiState = (dist < C.CANNON_RANGE && this.player.alive) ? 'ATTACK' : 'WANDER';
                        }

                        if (ship.aiState === 'WANDER') {
                            throttle = 0.8;
                            if (Math.random() < 0.05) ship.rotationSpeed = (Math.random() - 0.5) * 2;
                            turn = ship.rotationSpeed;
                            if (Math.abs(ship.mesh.position.x) > C.MAP_SIZE / 2 - 100) turn = 1; // Avoid edge
                        } else {
                            throttle = 0.6;
                            const dx = this.player.mesh.position.x - ship.mesh.position.x;
                            const dz = this.player.mesh.position.z - ship.mesh.position.z;
                            const angle = Math.atan2(dx, dz);
                            const desired = angle + Math.PI / 2;
                            let delta = desired - ship.mesh.rotation.y;
                            while (delta <= -Math.PI) delta += Math.PI * 2;
                            while (delta > Math.PI) delta -= Math.PI * 2;
                            turn = delta > 0 ? 1 : -1;

                            if (Math.abs(delta) < 0.5 && Math.random() < 0.03) this.fireCannons(ship, 1);
                        }
                    }

                    // Physics
                    if (throttle) ship.speed += throttle * dt * 8;
                    else ship.speed *= 0.98;
                    ship.speed = Math.max(-5, Math.min(C.SHIP_SPEED, ship.speed));

                    const turnFactor = Math.min(1, Math.abs(ship.speed) / 3);
                    ship.mesh.rotation.y += turn * C.TURN_SPEED * turnFactor * dt;

                    const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.mesh.quaternion);
                    ship.velocity.copy(fwd).multiplyScalar(ship.speed);
                    ship.mesh.position.add(ship.velocity.clone().multiplyScalar(dt));

                    // Buoyancy & Rocking
                    const y = this.getWaveHeight(ship.mesh.position.x, ship.mesh.position.z, time);
                    ship.mesh.position.y = y;

                    // Sample points for pitch/roll
                    const frontY = this.getWaveHeight(ship.mesh.position.x + Math.sin(ship.mesh.rotation.y) * 3, ship.mesh.position.z + Math.cos(ship.mesh.rotation.y) * 3, time);
                    const rightY = this.getWaveHeight(ship.mesh.position.x + Math.sin(ship.mesh.rotation.y - Math.PI / 2) * 2, ship.mesh.position.z + Math.cos(ship.mesh.rotation.y - Math.PI / 2) * 2, time);

                    const pitch = (y - frontY) * 0.15;
                    const roll = (y - rightY) * 0.15 - (turn * 0.15 * turnFactor);

                    ship.mesh.rotation.x = THREE.MathUtils.lerp(ship.mesh.rotation.x, pitch, dt * 2);
                    ship.mesh.rotation.z = THREE.MathUtils.lerp(ship.mesh.rotation.z, roll, dt * 2);

                    // Wake VFX
                    if (Math.abs(ship.speed) > 5 && Math.random() < 0.3) {
                        const wakePos = ship.mesh.position.clone().sub(fwd.multiplyScalar(2.5));
                        wakePos.y = y + 0.1;
                        this.vfx.spawn(wakePos, 'WAKE', 1);
                    }

                    // UI
                    if (ship.hpBar) {
                        const screenPos = ship.mesh.position.clone().add(new THREE.Vector3(0, 6, 0));
                        screenPos.project(this.camera);
                        const sx = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                        const sy = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                        if (screenPos.z < 1 && Math.abs(screenPos.x) < 1.2) {
                            ship.hpBar.style.display = 'block';
                            ship.hpBar.style.left = sx + 'px';
                            ship.hpBar.style.top = sy + 'px';
                            ship.hpBar.querySelector('.hp-fill').style.width = (ship.hp / ship.maxHp * 100) + '%';
                        } else {
                            ship.hpBar.style.display = 'none';
                        }
                    }
                });
            }

            updateProjectiles(dt) {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    p.life -= dt;
                    p.velocity.y -= C.GRAVITY * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    if (p.mesh.position.y < 0) {
                        this.audio.splash();
                        this.vfx.spawn(p.mesh.position, 'SPLASH', 3, 1.0);
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                        continue;
                    }

                    let hit = false;
                    for (let ship of this.ships) {
                        if (ship === p.owner || !ship.alive) continue;
                        if (p.mesh.position.distanceTo(ship.mesh.position) < 2.5 * (ship.level * 0.05 + 1)) {
                            this.audio.impact();
                            ship.hp -= 12 + (p.owner.level * 3);
                            this.vfx.spawn(p.mesh.position, 'WOOD', 4, 1.0);

                            if (ship.hp <= 0) this.sinkShip(ship, p.owner);
                            hit = true;
                            break;
                        }
                    }

                    if (hit || p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            sinkShip(ship, killer) {
                ship.alive = false;
                ship.hpBar.remove();
                this.audio.sink();
                this.vfx.spawn(ship.mesh.position, 'EXPLOSION', 8, 2.0);

                const sinkInterval = setInterval(() => {
                    ship.mesh.position.y -= 0.05;
                    ship.mesh.rotation.x += 0.02;
                    if (ship.mesh.position.y < -10) {
                        clearInterval(sinkInterval);
                        this.scene.remove(ship.mesh);
                    }
                }, 50);

                const lootCount = 2 + Math.floor(ship.level / 2);
                for (let i = 0; i < lootCount; i++) {
                    this.spawnCrate(ship.mesh.position.clone().add(new THREE.Vector3((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4)), 100);
                }

                if (!ship.isPlayer) {
                    setTimeout(() => {
                        const x = (Math.random() - 0.5) * C.MAP_SIZE * 0.8;
                        const z = (Math.random() - 0.5) * C.MAP_SIZE * 0.8;
                        this.spawnShip(x, z, false);
                    }, 4000);
                }
            }

            updateCrates(dt, time) {
                for (let i = this.crates.length - 1; i >= 0; i--) {
                    const c = this.crates[i];
                    if (!c.active) continue;
                    c.mesh.position.y = this.getWaveHeight(c.mesh.position.x, c.mesh.position.z, time);
                    c.mesh.rotation.y += dt;

                    if (this.player.alive && c.mesh.position.distanceTo(this.player.mesh.position) < 4) {
                        this.audio.gold();
                        this.player.score += c.value;
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + 25);

                        if (this.player.score > this.player.level * 600) {
                            this.player.level++;
                            this.player.maxHp += 25;
                            this.player.hp = this.player.maxHp;
                            this.player.mesh.scale.multiplyScalar(1.08);
                            this.vfx.spawn(this.player.mesh.position, 'EXPLOSION', 5, 2); // Level up effect
                        }

                        document.getElementById('score').innerText = 'GOLD: ' + this.player.score;
                        document.getElementById('level').innerText = 'LVL ' + this.player.level;

                        this.scene.remove(c.mesh);
                        this.crates.splice(i, 1);
                    }
                }
            }

            drawMinimap() {
                const ctx = this.minimapCtx;
                ctx.clearRect(0, 0, 180, 180);
                const scale = 180 / C.MAP_SIZE;
                const center = 90;

                // Islands (Static)
                ctx.fillStyle = '#F4A460';
                // Ideally we'd store island positions, but for now just draw ships

                if (this.player.alive) {
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(center + this.player.mesh.position.x * scale, center + this.player.mesh.position.z * scale, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // View Cone
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(center + this.player.mesh.position.x * scale, center + this.player.mesh.position.z * scale);
                    const rot = -this.player.mesh.rotation.y - Math.PI / 2;
                    ctx.lineTo(
                        center + this.player.mesh.position.x * scale + Math.cos(rot - 0.5) * 20,
                        center + this.player.mesh.position.z * scale + Math.sin(rot - 0.5) * 20
                    );
                    ctx.stroke();
                }

                ctx.fillStyle = '#FF0000';
                this.ships.forEach(s => {
                    if (!s.isPlayer && s.alive) {
                        ctx.beginPath();
                        ctx.arc(center + s.mesh.position.x * scale, center + s.mesh.position.z * scale, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            resize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const dt = Math.min(this.clock.getDelta(), 0.1);
                const time = this.clock.getElapsedTime();

                this.updateWater(time);
                this.updateShips(dt, time);
                this.updateProjectiles(dt);
                this.updateCrates(dt, time);
                this.vfx.update(dt);
                this.drawMinimap();

                if (this.player.alive) {
                    const targetPos = this.player.mesh.position.clone().add(new THREE.Vector3(0, 25 + (this.player.level * 1.5), 35 + (this.player.level * 1.5)));
                    this.camera.position.lerp(targetPos, 0.08);
                    this.camera.lookAt(this.player.mesh.position);
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        new Game();
    </script>
</body>

</html>